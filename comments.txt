src/0.c:	IN_initplayer(&player);//, 0);
src/0.c:		bakapee1 = FILENAME_1;//"data/aconita.vrl";
src/0.c:		bakapee2 = FILENAME_2;//"data/aconita.pal";
src/0.c:		//return 1;
src/0.c:	//4	this dose the screen
src/0.c:				vga_state.vga_graphics_ram[o] = (i^j)&15; // VRL samples put all colors in first 15!
src/0.c:	//while (getch() != 13);
src/0.c:		unsigned int overdraw = 1;	// how many pixels to "overdraw" so that moving sprites with edge pixels don't leave streaks.
src/0.c:						// if the sprite's edge pixels are clear anyway, you can set this to 0.
src/0.c:		//4	this dose the sprite? wwww
src/0.c:				vga_state.vga_graphics_ram[o] = (i^j)&15; // VRL samples put all colors in first 15!
src/0.c:		omemptr = vga_state.vga_graphics_ram; // save original mem ptr
src/0.c:			if(IN_KeyDown(68))	//f10
src/0.c:				//gvar.kurokku.fpscap=!gvar.kurokku.fpscap;
src/0.c:			o = (0x10000UL - (uint16_t)gvar.video.page[1].data) + (ry * gvar.video.page[0].stridew) + (rx >> 2); // source offscreen
src/0.c:			o = gvar.video.page[0].pagesize; // source offscreen
src/0.c:			o2 = (ry * gvar.video.page[0].stridew) + (rx >> 2); // dest visible (original stride)
src/0.c:			//printf("[x%u y%u]	[rx%u ry%u]		[w%u h%u]\n", x, y, rx, ry, w, h);
src/0.c:			dstart = (gvar.video.page[0].height - dh) / 2; // center the squash effect on screen, otherwise it would squash to top of screen
src/16.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/16.c:	// DOSLIB: check our environment
src/16.c:	// DOSLIB: what CPU are we using?
src/16.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/16.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/16.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/16.c:	//      the CPU to carry out tasks. --J.C.
src/16.c:	// DOSLIB: check for VGA
src/16.c:	// hardware must be VGA or higher!
src/16.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/16.c://	modexPalBlack();	//so player will not see loadings~
src/16.c:	//modexprint(&screen, 32, 32, 1, 2, 0, "a", 1);
src/16.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/bakapi4b.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/bakapi4b.c:	// main variables values
src/bakapi4b.c:	d=4; // switch variable
src/bakapi4b.c:	key=2; // default screensaver number
src/bakapi4b.c:// screen savers
src/bakapi4b.c:	while(d>0)	// on!
src/bakapi4b.c:		{ // conditions of screen saver
src/bakapi4b.c:			// user imput switch
src/bakapi4b.c:			printf("Enter 1, 2, 3, 4, or 6 to run a screensaver, or enter 0 to quit.\n", getch());  // prompt the user
src/bakapi4b.c:			//if(key==3){xx=yy=0;} // crazy screen saver wwww
src/bakapi4b.c://pee!
src/bakapi.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/bakapi.c:sword vgamodex_mode = 1; // 320x240 default
src/bakapi.c:	// allow changing default mode from command line
src/bakapi.c:				// (based on src/lib/modex16.c)
src/bakapi.c:				// 1 = 320x240
src/bakapi.c:				// 2 = 160x120
src/bakapi.c:				// 3 = 320x200
src/bakapi.c:				// 4 = 192x144
src/bakapi.c:				// 5 = 256x192
src/bakapi.c:	// DOSLIB: check our environment
src/bakapi.c:	// DOSLIB: what CPU are we using?
src/bakapi.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/bakapi.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/bakapi.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/bakapi.c:	//      the CPU to carry out tasks. --J.C.
src/bakapi.c:	// DOSLIB: check for VGA
src/bakapi.c:	// hardware must be VGA or higher!
src/bakapi.c:	// main variables values
src/bakapi.c:	d=4; // switch variable
src/bakapi.c:	key=2; // default screensaver number
src/bakapi.c:	VGAmodeX(vgamodex_mode, 1, &gvar); // TODO: Suggestion: Instead of magic numbers for the first param, might I suggest defining an enum or some #define constants that are easier to remember? --J.C.
src/bakapi.c:		// this code is written around modex16 which so far is a better fit than using DOSLIB vga directly, so leave MXLIB code in.
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:	//modexPalUpdate(bmp.palette); //____
src/bakapi.c:	//modexDrawBmp(VGA, 0, 0, &bmp, 0); //____
src/bakapi.c:	//getch(); //____
src/bakapi.c:// screen savers
src/bakapi.c:	while(d>0)	// on!
src/bakapi.c:					getch(); // eat keyboard input
src/bakapi.c:				//right movement
src/bakapi.c:				//left movement
src/bakapi.c:				//down movement
src/bakapi.c:				//up movement
src/bakapi.c:					//getch(); // eat keyboard input
src/bakapi.c:					break; // 'q' or 'ESC' or 'p'
src/bakapi.c:		// this code is written around modex16 which so far is a better fit than using DOSLIB vga directly, so leave MXLIB code in.
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:			// user imput switch
src/bakapi.c:			//fprintf(stderr, "xx=%d	yy=%d	tile=%d\n", bakapee.xx, bakapee.yy, bakapee.tile);
src/bakapi.c:			//fprintf(stderr, "dx=%d	dy=%d	", gvar.video.page[0].dx, gvar.video.page[0].dy);
src/bakapi.c:			//printf("\n");
src/bakapi.c:				case 'p': // test pan
src/bakapi.c:				case 'b': // test tile change
src/bakapi.c:		// this code is written around modex16 which so far is a better fit than using DOSLIB vga directly, so leave MXLIB code in.
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:#else // !defined(BOINK)
src/bakapi.c:// FIXME: Does not compile. Do you want to remove this?
src/bakapi.c:// INFO: This is a testing section for textrendering and panning for project 16 --sparky4
src/bakapi.c:	{ // conditions of screen saver
src/bakapi.c:// 		while(!kbhit())
src/bakapi.c:// 		{
src/bakapi.c:// 			ding(&gvar.video.page[0], &bakapee, key);
src/bakapi.c:// 		}
src/bakapi.c:		//end of screen savers
src/bakapi.c:		//pdump(&gvar.video.page[0]);
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-48, "========================================");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-40, "|    |Chikyuu:$line1");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-32, "|    |$line2");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-24, "|    |$line3");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-16, "|    |$line4");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-8,  "========================================");
src/bakapi.c:// 	xpos+=xdir;
src/bakapi.c:// 	ypos+=ydir;
src/bakapi.c:// 	if( (xpos>(gvar.video.page[0].sw-gvar.video.page[0].width-1))  || (xpos<1)){xdir=-xdir;}
src/bakapi.c:// 	if( (ypos>(gvar.video.page[0].sh-gvar.video.page[0].height-1)) || (ypos<1)){ydir=-ydir;}
src/bakapi.c://	ch=getch();
src/bakapi.c:	if(ch==0x71)break; // 'q'
src/bakapi.c:	if(ch==0x1b)break; // 'ESC'
src/bakapi.c:#endif // defined(BOINK)
src/bakapi.c://	printf("page.width=%u	", gvar.video.page[0].width); printf("page.height=%u\n", gvar.video.page[0].height);
src/bakapi.c://pee!
src/bakapi.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/bakapi.h://project 16 testing define switch for veiwing the contents of the video memory --sparky4
src/bakapi.h:#define BOINK // what does this mean? --J.C.
src/emmtest.c:// Cut this out as emm.c
src/emmtest.c:	{		// make sure we got EMM
src/emmtest.c:		//printf("EMM Hardware Information %lu\n", EMInfo());
src/emmtest.c:	//printf("b4 EMS	*pEmmData=%s\n", *pEmmData);
src/emmtest.c:	pEmmData = (byte *)EMMalloc(&hEData, EMMCoreLeft());  // get 6 * 16K bytes - 96K
src/emmtest.c:	MapEMM(hEData, 0, PEMMDATAPAGENUM);   // load 1st 4 pages into page frame: 0-3
src/emmtest.c:	//memset(pEmmData, 0x0e, 64000u);
src/emmtest.c://0000	printf("(advi*EMMPAGESIZE)=%lu\n", advi);
src/emmtest.c:	memset(pEmmData, atoi(argv[1]), 0xffff);//sizeof(atoi(argv[1])));//((EMMCoreLeft())*EMMPAGESIZE));
src/emmtest.c://qqqq	memset(pEmmData+0x10000, atoi(argv[1]), 0xffff);//sizeof(atoi(argv[1])));//((EMMCoreLeft())*EMMPAGESIZE));
src/emmtest.c://----	UnmapEMM(hEData, 0, 4);          // not absolutely necessary
src/emmtest.c:	MapEMM(hEData, 4, 2);            // map last 2 pages: 4-5
src/emmtest.c://	memset(pEmmData, atoi(argv[0]), 32768u);
src/emmtest.c:   // do some stuff with the first 64K of file data.
src/emmtest.c:   MapEMM(hEData, 4, 2);  // only unmaps 1st two pages of prior 64k mapping
src/emmtest.c:   // do stuff with remaining 32K of data
src/emmtest.c:	//		(*p)++;
src/emmtest.c:	//		(*p)++;
src/emmtest.c:		//free(p);
src/emmtest.c:		UnmapEMM(hEData, 0, PEMMDATAPAGENUM);  // should unmap before freeing
src/emmtest.c:		//printf("after EMS	*pEmmData=%c\n", *pEmmData);
src/emmtest.c:		EMMFree(hEData);     // finished with the file data
src/emmtest.c:	//printf("EMMPAGESIZE=%d\n", EMMPAGESIZE);
src/emsdump.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/emsdump.c://#include <limits.h>
src/emsdump.c:	char huge *p =(char huge *)(GetEMMSeg0()*0x10000);//0xD0000000;
src/emsdump.c:	//char far *q =(char far *)0x53332225;
src/emsdump.c:	//while(!kbhit()){		printf("%p\n", ((GetEMMSeg0()*0x10000)+0x0fffffff));	}
src/emsdump.c:	//while(!kbhit()){		printf("%p\n", ((GetEMMSeg0()*0x10000)+0xffff));	}
src/emsdump.c:		//else printf("%p=	%x%	%ul\n", p, *p, i);
src/emsdump.c://		(*p)++;
src/emsdump.c://		printf("				%p\n", ((GetEMMSeg0()*0x10000)+0x0fffffff));
src/emsdump.c:	//printf("*q=%d\n",*q);
src/emsdump.c:	//printf(" q=%p\n", q);
src/exmmtest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/exmmtest.c://#include "src/lib/16_vl.h"
src/exmmtest.c://file load or read definition
src/exmmtest.c://#define EXMMVERBOSE
src/exmmtest.c:// 	printf("Next string is: [");
src/exmmtest.c:// 	while(*scrptr<16)
src/exmmtest.c:// 	{
src/exmmtest.c:// 		printf("%c", *(screen:>scrptr));
src/exmmtest.c:// 		//printf("\b");
src/exmmtest.c:// 		scrptr++;
src/exmmtest.c://
src/exmmtest.c:// 	}
src/exmmtest.c:// 	printf("]\n");
src/exmmtest.c://	printf("press any key to continue!\n");
src/exmmtest.c://	getch();
src/exmmtest.c://static global_game_variables_t gvar;
src/exmmtest.c://#ifdef __WATCOMC__
src/exmmtest.c://	__segment sega;
src/exmmtest.c://#endif
src/exmmtest.c:	//static byte bakapee[64];
src/exmmtest.c:	//file name //
src/exmmtest.c:	//file name //
src/exmmtest.c:	dbg_debugpm=1;	//debug pm
src/exmmtest.c:	//PRINTBB
src/exmmtest.c:	//{ printf("filename!: "); scanf("%[^\n]", &bakapee); }
src/exmmtest.c:	//printf("main()=%Fp	start MM\n", *argv[0]);
src/exmmtest.c:	//printf("ok\n");
src/exmmtest.c://#ifdef __WATCOMC__
src/exmmtest.c:		//printf("pmstarted ok\n");
src/exmmtest.c:		//PM_CheckMainMem(&gvar);
src/exmmtest.c://#endif
src/exmmtest.c://	printf("		done!\n");
src/exmmtest.c:	//0000PRINTBB;
src/exmmtest.c://	printf("press any key to continue!\n");
src/exmmtest.c://	getch();
src/exmmtest.c://	bakapeehandle = open(bakapee,O_RDONLY | O_BINARY, S_IREAD);
src/exmmtest.c://	printf("size of big buffer~=%u\n", _bmsize(segu, bigbuffer));
src/exmmtest.c://	if(CA_FarRead(bakapeehandle,(void far *)&bigbuffer,sizeof(bigbuffer),&gvar.mm))
src/exmmtest.c://	close(bakapeehandle);
src/exmmtest.c:	//hmm functions in cache system use the buffered stuff
src/exmmtest.c://#ifdef __WATCOMC__
src/exmmtest.c://	printf("\nsize of big buffer~=%u\n", _bmsize(sega, bigbuffer));
src/exmmtest.c://#endif
src/exmmtest.c:	//printf("dark purple = purgable\n");
src/exmmtest.c:	//printf("medium blue = non purgable\n");
src/exmmtest.c:	//printf("red = locked\n");
src/exmmtest.c://	printf("press any key to continue!\n");
src/exmmtest.c://	DebugMemory_(&gvar, 1);
src/exmmtest.c:	//printf("bakapee1=%s\n", bakapee1);
src/exmmtest.c:	//printf("bakapee2=%s\n", bakapee2);
src/exmmtest.c://#ifdef __WATCOMC__
src/exmmtest.c://#endif
src/exmmtest.c:	//printf("bigbr=	%04x", bigbuffer);
src/exmmtest.c:	//printf("\n");
src/exmmtest.c:	//printf("&bigb=%04x", &bigbuffer);
src/exmmtest.c://this is far	printf("Total free:			%lu\n", (dword)(GetFreeSize()));
src/exmmtest.c:	//printf("core left:			%lu\n", (dword)_coreleft());
src/exmmtest.c:	//printf("far core left:			%lu\n", (dword)_farcoreleft());
src/exmmtest.c:	//printf("based core left:			%lu\n", (dword)_basedcoreleft());
src/exmmtest.c:	//printf("huge core left:			%lu\n", (dword)_hugecoreleft());
src/fmemtest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/fmemtest.c:	//void __based(__self) *pee;
src/fmemtest.c:	//word csw=0,dsw=0,esw=0,ssw=0,ipw=0;
src/fmemtest.c:	//ptr=&x;
src/fmemtest.c:	//printf("&ptr0=%Fp\n", &ptr0);
src/fmemtest.c:	//printf("&ptr=%Fp\n", &ptr);
src/fmemtest.c:		//lea csw,cs
src/fmemtest.c:		//lds DS,dsw
src/fmemtest.c:		//les ES,esw
src/fmemtest.c://		mov ss,ssw
src/fmemtest.c://		mov ip,ipw
src/fmemtest.c:	//printf("ip=%u\n", ipw);
src/fmemtest.c:	//printf("ss=%u\n", ssw);
src/fmemtest.c:	//printf("cs=%u\n", csw);
src/fmemtest.c:	//printf("ds=%u\n", dsw);
src/fmemtest.c:	//printf("es=%u\n", esw);
src/fontgfx.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/fontgfx.c://#include "lib/16text.h"
src/fontgfx.c:	//JMOJI
src/fontgfx.c:	//word ri;
src/fontgfx.c:	byte pee[6]; // must be large enough for sprintf("%zc",...) and sprintf("%u",(byte value))
src/fontgfx.c://	static byte *rosa;
src/fontgfx.c:	// DOSLIB: check our environment
src/fontgfx.c:	// DOSLIB: what CPU are we using?
src/fontgfx.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/fontgfx.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/fontgfx.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/fontgfx.c:	//      the CPU to carry out tasks. --J.C.
src/fontgfx.c:	// DOSLIB: check for VGA
src/fontgfx.c:	// hardware must be VGA or higher!
src/fontgfx.c:	// NTS: We're in Mode-X now. printf() is useless. Do not use printf(). Or INT 10h text printing. Or DOS console output.
src/fontgfx.c:	//modexprint(16, 16, 1, 15, "wwww");
src/fontgfx.c:	//getch();
src/fontgfx.c://	vga_moveto(0,0);
src/fontgfx.c://	vga_sync_bios_cursor();
src/fontgfx.c:			//getch();
src/fontgfx.c:	//modexprint(100, 100, 1, 47, 0, "wwww");
src/fontgfx.c://	modexprint(0, 0, 1, 0, colpee, &rose);
src/fontgfx.c://++++	modexprint(&gvar.video.page[0], 0, 0, 0, 0, colpee, &ibmlogo);
src/fontgfx.c://	modexprintbig(&gvar.video.page[0], 0, 0, 1, colpee, 0, "IBM");
src/fontgfx.c://	modexprint(0, 0, 1, 0, colpee, ROSE);
src/fontgfx.c://++++	getch();
src/fontgfx.c://	rosa=malloc(sizeof(ROSE));
src/fontgfx.c://	(*rosa)=(byte)ROSE;
src/fontgfx.c:	//printf("\nh=%d\n", '8');
src/fontgfx.c://	printf("\n%c\n", e);
src/fonttest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/fonttest.c:    //print the addresses of the fonts
src/fonttest.c://	printf("*argv[1]=%d\n", *argv[1]);
src/fonttest.c:    //load the letter 'A'
src/fonttest.c:    //render the letter in ascii art
src/inputest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/inputest.c:	//extern struct inconfig inpu;
src/inputest.c:	//while(!IN_KeyDown(sc_Escape))
src/inputest.c:		//shinkutxt(&gvar);
src/inputest.c:		//right movement
src/inputest.c:		//left movement
src/inputest.c:		//down movement
src/inputest.c:		//up movement
src/inputest.c:		//printf("%u\n", IN_KeyDown(sc_Escape));
src/inputest.c:		//if(
src/inputest.c:		IN_qb(sc_9);//>0) printf("IN_qb(sc_9)=%u\n", IN_qb(sc_9));
src/inputest.c:		if(IN_KeyDown(88))	//speed
src/inputest.c:			//IN_Ack();
src/inputest.c:	//printf("%u\n", in.Keyboard[sc_Escape]);
src/maptest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/maptest.c://TODO: ADD MEMORY MANAGER! WWWW
src/maptest.c:	//fprintf(stderr, "program always crashes for some reason....\n");
src/midi.c://							fprintf(stderr,"Type 0x7F len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/midi.c://								fprintf(stderr,"Type 0x%02x len=%lu %p/%p/%p\n",c,d,t->raw,t->read,t->fence);
src/midi.c://						fprintf(stderr,"Sysex len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/midi.c://	midi_tick();
src/miditest.c:	//adlib_shut_up();
src/miditest.c:		//adv = ptick;
src/miditest.c:		//ptick++;
src/miditest.c:	//adlib_shut_up();
src/palettec.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/palettel.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/palettel.c:	//page.width += 32;
src/palettel.c:	//page.height += 32;
src/palettel.c://	modexPalSave(pal);
src/pcxtest2.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/pcxtest2.c://----#include "src/lib/planar.h"
src/pcxtest2.c:	// TODO Make this fast.  It's SLOOOOOOW
src/pcxtest2.c:		//offset+=p->width;
src/pcxtest2.c:		//offset++;
src/pcxtest2.c://----	planar_buf_t *p;
src/pcxtest2.c:	// DOSLIB: check our environment
src/pcxtest2.c:	// DOSLIB: what CPU are we using?
src/pcxtest2.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/pcxtest2.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/pcxtest2.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/pcxtest2.c:	//      the CPU to carry out tasks. --J.C.
src/pcxtest2.c:	// DOSLIB: check for VGA
src/pcxtest2.c:	// hardware must be VGA or higher!
src/pcxtest2.c://0000	bmp = bitmapLoadPcx("data/koishi~~.pcx");
src/pcxtest2.c://	bmp = bitmapLoadPcx("data/koishi^^.pcx");
src/pcxtest2.c://	bmp = bitmapLoadPcx("16/PCX_LIB/chikyuu.pcx");
src/pcxtest2.c://----	p = planar_buf_from_bitmap(&bmp);
src/pcxtest2.c:	//for(i=0; i<100 ;i++) {
src/pcxtest2.c:	//}
src/pcxtest2.c:	//for(i=0; i<100 ;i++) {
src/pcxtest2.c://0000		modexDrawBmp(&gvar.video.page[0], 20, 20, &bmp);
src/pcxtest2.c:	//}
src/pcxtest2.c:	//for(i=0; i<100; i++) {
src/pcxtest2.c://0000		modexCopyPageRegion(&gvar.video.page[0], &gvar.video.page[0], 20, 20, 128, 20, 64, 64);
src/pcxtest2.c:	//}
src/pcxtest2.c:	//for(i=0; i<100 ;i++) {
src/pcxtest2.c:	//}
src/pcxtest2.c:	//for(i=0; i<100 ;i++) {
src/pcxtest2.c://0000		modexDrawSprite(&gvar.video.page[0], 20, 20, &bmp);
src/pcxtest2.c:	//}
src/pcxtest2.c:	//_fmemset(MK_FP(0xA000, 0), (int)p->plane, gvar.video.page[0].sw*(gvar.video.page[0].sh*2));
src/pcxtest2.c:	//modexDrawBmp(&gvar.video.page[0], 0, 0, &bmp);
src/pcxtest2.c:		//DrawPBuf(&gvar.video.page[0], 0, 0, p, 0);
src/pcxtest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/pcxtest.c://----#include "src/lib/planar.h"
src/pcxtest.c://----	planar_buf_t *p;
src/pcxtest.c:	// DOSLIB: check our environment
src/pcxtest.c:	// DOSLIB: what CPU are we using?
src/pcxtest.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/pcxtest.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/pcxtest.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/pcxtest.c:	//      the CPU to carry out tasks. --J.C.
src/pcxtest.c:	// DOSLIB: check for VGA
src/pcxtest.c:	// hardware must be VGA or higher!
src/pcxtest.c://0000	bmp = bitmapLoadPcx("data/koishi~~.pcx");
src/pcxtest.c://	bmp = bitmapLoadPcx("data/koishi^^.pcx");
src/pcxtest.c://	bmp = bitmapLoadPcx("16/PCX_LIB/chikyuu.pcx");
src/pcxtest.c://----	p = planar_buf_from_bitmap(&bmp);
src/pcxtest.c:	//for(i=0; i<100 ;i++) {
src/pcxtest.c:	//}
src/pcxtest.c:	//for(i=0; i<100 ;i++) {
src/pcxtest.c://0000		modexDrawBmp(&gvar.video.page[0], 20, 20, &bmp);
src/pcxtest.c:	//}
src/pcxtest.c:	//for(i=0; i<100; i++) {
src/pcxtest.c://0000		modexCopyPageRegion(&gvar.video.page[0], &gvar.video.page[0], 20, 20, 128, 20, 64, 64);
src/pcxtest.c:	//}
src/pcxtest.c:	//for(i=0; i<100 ;i++) {
src/pcxtest.c:	//}
src/pcxtest.c:	//for(i=0; i<100 ;i++) {
src/pcxtest.c://0000		modexDrawSprite(&gvar.video.page[0], 20, 20, &bmp);
src/pcxtest.c:	//}
src/pcxtest.c:	//_fmemset(MK_FP(0xA000, 0), (int)p->plane, gvar.video.page[0].sw*(gvar.video.page[0].sh*2));
src/pcxtest.c:	//modexDrawBmp(&gvar.video.page[0], 0, 0, &bmp);
src/pcxtest.c:		//DrawPBuf(&gvar.video.page[0], 0, 0, p, 0);
src/planrpcx.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/planrpcx.c:word start;//,	w;
src/planrpcx.c://w=0;
src/planrpcx.c://printf("%u ", w++);
src/planrpcx.c://	if(argv[2]) baka = atoi(argv[2]);
src/planrpcx.c://	else
src/planrpcx.c://fprintf(stderr, "%u ", w++);
src/planrpcx.c://fprintf(stderr, "%u ", w++);
src/planrpcx.c://	ptmp = planarLoadPcx("data/ptmp.pcx");
src/planrpcx.c://fprintf(stderr, "%u ", w++);
src/planrpcx.c://fprintf(stderr, "^^;", w++);
src/planrpcx.c://getch();
src/planrpcx.c:	//fix up the palette and everything
src/planrpcx.c:	//clear and draw one sprite and one bitmap
src/planrpcx.c:	//update display~
src/planrpcx.c:	//non sprite comparison
src/planrpcx.c:// 		oldDrawBmp(VGA, 20, 20, &bmp, 0);
src/planrpcx.c:		//modexDrawBmpPBuf		(&gvar.video.page[0], 32, 32, &p);
src/planrpcx.c:// 	start = *clockw;
src/planrpcx.c:// 		modexCopyPageRegion(&gvar.video.page[0], &gvar.video.page[0], 0, 0, 0, 0, 320, 240);
src/planrpcx.c:// 	t2 = (*clockw-start)/18.2;
src/planrpcx.c:						//(page_t *page, int x, int y, int rx, int ry, int rw, int rh, planar_buf_t *p, boolean sprite);
src/planrpcx.c:		modexDrawPBufRegion	(&gvar.video.page[0], p.width, 0, p.width-(p.width/4), p.height-(p.height/4), p.width/4, p.height/4, &p, 0);//(&gvar.video.page[0], 0, 0, 0+p.width, 0, p.width, p.height, &p, 0);
src/planrpcx.c:	//++++	modexPalUpdate1(ptmp.palette);
src/planrpcx.c:	//modexDrawBmpPBufRegion(&gvar.video.page[0], 64, 64, 48, 32, 24, 32, ptmp);
src/planrpcx.c:	//modexDrawPBuf(&gvar.video.page[0], 64, 64, &ptmp, 0);
src/planrpcx.c:	//print out the contents of each plane
src/planrpcx.c:	//fprintf(stderr, "gvar.video.page[0].width: %u\n", gvar.video.page[0].width);
src/planrpcx.c:	//fprintf(stderr, "gvar.video.page[0].height: %u\n", gvar.video.page[0].height);
src/_scroll.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/_scroll.c://#include "src/lib/16_head.h"//included already
src/_scroll.c://#define FADE
src/_scroll.c:#define MODEX	//this is for mode x initiating
src/_scroll.c://word far *clock= (word far*) 0x046C; /* 18.2hz clock */
src/_scroll.c://bitmap_t *p;
src/_scroll.c://word pn=0; //i forgot ww
src/_scroll.c://debugswitches
src/_scroll.c://extern boolean pageflipflop=1;
src/_scroll.c:	//static int persist_aniframe = 0;    /* gonna be increased to 1 before being used, so 0 is ok for default */
src/_scroll.c:	//map_view_db_t pgid[4];
src/_scroll.c://#ifdef FADE
src/_scroll.c://#endif
src/_scroll.c:	// DOSLIB: check our environment
src/_scroll.c:	// DOSLIB: what CPU are we using?
src/_scroll.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/_scroll.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/_scroll.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/_scroll.c:	//      the CPU to carry out tasks. --J.C.
src/_scroll.c:	// DOSLIB: check for VGA
src/_scroll.c:	// hardware must be VGA or higher!
src/_scroll.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/_scroll.c: *	read_vrs(&gvar, "data/spri/chikyuu.vrs", player[0].spri->spritesheet); // load sprite
src/_scroll.c:	modexPalBlack();	//reset the palette~
src/_scroll.c:	modexPalBlack();	//so player will not see loadings~
src/_scroll.c:	//TODO: LOAD map data and position the map in the middle of the screen if smaller then screen
src/_scroll.c:	//_fmemcpy(mv[1].page->data, mv[0].page->data, mv[0].page->pagesize);
src/_scroll.c:	//TODO: put player in starting position of spot
src/_scroll.c:	//default player position on the viewable map
src/_scroll.c:	//IN_initplayer(&player, 1);
src/_scroll.c:	//modexClearRegion(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 32, 15);
src/_scroll.c:	//PBUFSFUN(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 64, 24, 32,	PLAYERBMPDATA);
src/_scroll.c:	//PBUFSFUN(mv[0].page, player[0].x, player[0].y-TILEWH, 16, 64, 16, 32,	player[0].data);
src/_scroll.c:	else			modexShowPage(mv[0].page);//!(gvar.video.p)
src/_scroll.c:		shinku_fps_indicator_page = 0; // we're on page 1 now, shinku(). follow along please or it will not be visible.
src/_scroll.c:// 	modexClearRegion(mv[2].page, 0, 0, mv[2].page->width, mv[2].page->height, 47);
src/_scroll.c:// 	modexClearRegion(mv[3].page, 0, 0, mv[3].page->width, mv[3].page->height, 45);
src/_scroll.c:// 	{
src/_scroll.c:// 		unsigned int k,j,o;
src/_scroll.c:// 		/* fill screen with a distinctive pattern */
src/_scroll.c:// 		for (k=0;k < vga_state.vga_width;k++) {
src/_scroll.c:// 			o = k >> 2;
src/_scroll.c:// 			vga_write_sequencer(0x02/*map mask*/,1 << (k&3));
src/_scroll.c:// 				for (j=0;j < vga_state.vga_height;j++,o += vga_state.vga_stride)
src/_scroll.c:// 					vga_state.vga_graphics_ram[o] = (k^j)&15; // VRL samples put all colors in first 15!
src/_scroll.c:// 		}
src/_scroll.c:// 	}
src/_scroll.c:	//top left corner & bottem right corner of map veiw be set as map edge trigger since maps are actually square
src/_scroll.c:	//to stop scrolling and have the player position data move to the edge of the screen with respect to the direction
src/_scroll.c:	//when player[0].tx or player[0].ty == 0 or player[0].tx == 20 or player[0].ty == 15 then stop because that is edge of map and you do not want to walk of the map
src/_scroll.c:	//player movement
src/_scroll.c:		//printf("	player[0].q: %d", player[0].q);	printf("	player[0].d: %d\n", player[0].d);
src/_scroll.c:	//the scripting stuff....
src/_scroll.c:	//if(((player[0].triggerx == TRIGGX && player[0].triggery == TRIGGY) && IN_KeyDown(0x1C))||(player[0].tx == 5 && player[0].ty == 5))
src/_scroll.c:	//debugging binds!
src/_scroll.c:	}	//p
src/_scroll.c://	paloffset=0; modexPalBlack(); modexPalUpdate(player[0].data, &paloffset, 0, 0);
src/_scroll.c://	printf("1paloffset	=	%d\n", paloffset/3);
src/_scroll.c://	 modexPalUpdate(map.tiles->data, &paloffset, 0, 0);
src/_scroll.c://	printf("2paloffset	=	%d\n", paloffset/3);
src/_scroll.c://	 modexpdump(mv[0].page); modexpdump(mv[1].page);
src/_scroll.c:	//pan switch
src/_scroll.c:	if(IN_KeyDown(88)){panswitch=!panswitch; IN_UserInput(1,1);}	//f12
src/_scroll.c:	if(IN_KeyDown(87))	//f11
src/_scroll.c:// 		VGAmodeX(0, 0, &gvar);
src/_scroll.c:// 		IN_Shutdown();
src/_scroll.c:// 		__asm
src/_scroll.c:// 		{
src/_scroll.c:// 			mov ah,31h
src/_scroll.c:// 			int 21h
src/_scroll.c:// 		}
src/_scroll.c:	if(IN_KeyDown(68))	//f10
src/_scroll.c:	if(IN_KeyDown(67))	//f9
src/_scroll.c:		//IN_UserInput(1,1);
src/_scroll.c:	if(IN_KeyDown(66))	//f8
src/_scroll.c://		modexDrawSprite(mv[0].page, 16, 16, p);
src/_scroll.c://		modexDrawSprite(mv[0].page, 32+48, 16, (player[0].data));
src/_scroll.c:	//TODO fmemtest into page
src/_scroll.c:	/*if(IN_KeyDown(4+1))	//4
src/_scroll.c:	//9
src/_scroll.c:	//if(IN_KeyDown(11)){ modexPalOverscan(15); }
src/_scroll.c:	if((player[0].q==1) && !(player[0].x%TILEWH==0 && player[0].y%TILEWH==0)) break;	//incase things go out of sync!
src/_scroll.c:	//if(player[0].hp==0) printf("%d wwww\n", player[0].y+8);
src/_scroll.c:	//else printf("\nplayer[0].y: %d\n", player[0].y);
src/_scroll.c://	printf("palette offset:	%d\n", paloffset/3);
src/_scroll.c://++++	printf("Total used: %zu\n", oldfreemem-GetFreeSize());
src/_scroll.c://++++	printf("Total free: %zu\n", GetFreeSize());
src/_scroll.c://not used now	printf("temporary player sprite 0: http://www.pixiv.net/member_illust.php?mode=medium&illust_id=45556867\n");
src/_scroll.c://not used now	printf("temporary player sprite 1: http://www.pixiv.net/member_illust.php?mode=medium&illust_id=44606385\n");
src/_scroll.c:	//printf("mv[%u].tx: %d", pan.pn, mv[pan.pn].tx); printf("	mv[%u].ty: %d	", pan.pn, mv[pan.pn].ty);
src/_scroll.c:	//0000printf("\ngvar.video.tickclk=%f\n", gvar.video.tickclk);
src/_scroll.c:	//0000printf("gvar.video.clk=%f", gvar.video.clk);
src/_scroll.c:	//printf("map.width=%d	map.height=%d	map.data[0]=%d\n", mv[0].map->width, mv[0].map->height, mv[0].map->data[0]);
src/scroll.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/scroll.c://#define FADE
src/scroll.c:#define MODEX	//this is for mode x initiating
src/scroll.c://word far *clock= (word far*) 0x046C; /* 18.2hz clock */
src/scroll.c://bitmap_t *p;
src/scroll.c://word pn=0; //i forgot ww
src/scroll.c://debugswitches
src/scroll.c://extern boolean pageflipflop=1;
src/scroll.c:	//static int persist_aniframe = 0;    /* gonna be increased to 1 before being used, so 0 is ok for default */
src/scroll.c:	//map_view_db_t pgid[4];
src/scroll.c://#ifdef FADE
src/scroll.c:	//static word paloffset=0;
src/scroll.c://#endif
src/scroll.c:	//byte *mesg=malloc(sizeof(dword));
src/scroll.c:	// DOSLIB: check our environment
src/scroll.c:	// DOSLIB: what CPU are we using?
src/scroll.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/scroll.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/scroll.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/scroll.c:	//      the CPU to carry out tasks. --J.C.
src/scroll.c:	// DOSLIB: check for VGA
src/scroll.c:	// hardware must be VGA or higher!
src/scroll.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/scroll.c:	//mappalptr = map.tiles->btdata->palette;
src/scroll.c:	player[0].data = malloc(48*128); //TODO use exmm
src/scroll.c:	*player[0].data = bitmapLoadPcx("data/chikyuu.pcx"); // load sprite
src/scroll.c:////++++	(player[0].data) = *planar_buf_from_bitmap(&p);
src/scroll.c:	//IN_Default(1,&player,ctrl_Joystick);
src/scroll.c://	printf("%dx%d\n", gvar.video.page[0].sw, gvar.video.page[0].sh);
src/scroll.c:	modexPalBlack();	//reset the palette~
src/scroll.c://	printf("Total used @ before palette initiation:		%zu\n", oldfreemem-GetFreeSize());
src/scroll.c://++++	player[0].data.offset=(paloffset/3);
src/scroll.c://++++	modexPalUpdate1(&player[0].data, &paloffset, 0, 0);
src/scroll.c://++++0000		modexPalUpdate1(map.tiles->btdata->palette);
src/scroll.c:	//printf("	%d\n", sizeof(ptmp->data));
src/scroll.c:	//printf("1:	%d\n", paloffset);
src/scroll.c://++++	map.tiles->data->offset=(paloffset/3);
src/scroll.c:	//XTmodexPalUpdate(map.tiles->data, &paloffset, 0, 0);
src/scroll.c://	printf("\n====\n");
src/scroll.c://	printf("0	paloffset=	%d\n", paloffset/3);
src/scroll.c://	printf("====\n\n");
src/scroll.c:	modexPalBlack();	//so player will not see loadings~
src/scroll.c:	//TODO: LOAD map data and position the map in the middle of the screen if smaller then screen
src/scroll.c:	//_fmemcpy(mv[1].page->data, mv[0].page->data, mv[0].page->pagesize);
src/scroll.c:	//TODO: put player in starting position of spot
src/scroll.c:	//default player position on the viewable map
src/scroll.c:	IN_initplayer(&player);//, 0);
src/scroll.c:	//IN_initplayer(&player, 1);
src/scroll.c:	//modexClearRegion(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 32, 15);
src/scroll.c:	//PBUFSFUN(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 64, 24, 32,	PLAYERBMPDATA);
src/scroll.c:	else			modexShowPage(mv[0].page);//!(gvar.video.p)
src/scroll.c:		shinku_fps_indicator_page = 0; // we're on page 1 now, shinku(). follow along please or it will not be visible.
src/scroll.c:// 	modexClearRegion(mv[2].page, 0, 0, mv[2].page->width, mv[2].page->height, 47);
src/scroll.c:// 	modexClearRegion(mv[3].page, 0, 0, mv[3].page->width, mv[3].page->height, 45);
src/scroll.c:// 	{
src/scroll.c:// 		unsigned int k,j,o;
src/scroll.c:// 		/* fill screen with a distinctive pattern */
src/scroll.c:// 		for (k=0;k < vga_state.vga_width;k++) {
src/scroll.c:// 			o = k >> 2;
src/scroll.c:// 			vga_write_sequencer(0x02/*map mask*/,1 << (k&3));
src/scroll.c:// 				for (j=0;j < vga_state.vga_height;j++,o += vga_state.vga_stride)
src/scroll.c:// 					vga_state.vga_graphics_ram[o] = (k^j)&15; // VRL samples put all colors in first 15!
src/scroll.c:// 		}
src/scroll.c:// 	}
src/scroll.c:	//top left corner & bottem right corner of map veiw be set as map edge trigger since maps are actually square
src/scroll.c:	//to stop scrolling and have the player position data move to the edge of the screen with respect to the direction
src/scroll.c:	//when player[0].tx or player[0].ty == 0 or player[0].tx == 20 or player[0].ty == 15 then stop because that is edge of map and you do not want to walk of the map
src/scroll.c:	//player movement
src/scroll.c:		//printf("	player[0].q: %d", player[0].q);	printf("	player[0].d: %d\n", player[0].d);
src/scroll.c:	//the scripting stuff....
src/scroll.c:	//if(((player[0].triggerx == TRIGGX && player[0].triggery == TRIGGY) && IN_KeyDown(0x1C))||(player[0].tx == 5 && player[0].ty == 5))
src/scroll.c:	//debugging binds!
src/scroll.c:	}	//p
src/scroll.c:	//pan switch
src/scroll.c:	if(IN_KeyDown(88)){panswitch=!panswitch; IN_UserInput(1,1);}	//f12
src/scroll.c:	if(IN_KeyDown(87))	//f11
src/scroll.c:// 		VGAmodeX(0, 0, &gvar);
src/scroll.c:// 		IN_Shutdown();
src/scroll.c:// 		__asm
src/scroll.c:// 		{
src/scroll.c:// 			mov ah,31h
src/scroll.c:// 			int 21h
src/scroll.c:// 		}
src/scroll.c:	if(IN_KeyDown(68))	//f10
src/scroll.c:	if(IN_KeyDown(67))	//f9
src/scroll.c:		//IN_UserInput(1,1);
src/scroll.c:	if(IN_KeyDown(66))	//f8
src/scroll.c://		modexDrawSprite(mv[0].page, 16, 16, p);
src/scroll.c:	//TODO fmemtest into page
src/scroll.c:	/*if(IN_KeyDown(4+1))	//4
src/scroll.c:	//9
src/scroll.c:	//if(IN_KeyDown(11)){ modexPalOverscan(15); }
src/scroll.c:	if((player[0].q==1) && !(player[0].x%TILEWH==0 && player[0].y%TILEWH==0)) break;	//incase things go out of sync!
src/scroll.c:	//if(player[0].hp==0) printf("%d wwww\n", player[0].y+8);
src/scroll.c:	//else printf("\nplayer[0].y: %d\n", player[0].y);
src/scroll.c://	printf("palette offset:	%d\n", paloffset/3);
src/scroll.c://++++	printf("Total used: %zu\n", oldfreemem-GetFreeSize());
src/scroll.c://++++	printf("Total free: %zu\n", GetFreeSize());
src/scroll.c://not used now	printf("temporary player sprite 0: http://www.pixiv.net/member_illust.php?mode=medium&illust_id=45556867\n");
src/scroll.c://not used now	printf("temporary player sprite 1: http://www.pixiv.net/member_illust.php?mode=medium&illust_id=44606385\n");
src/scroll.c:	//printf("mv[%u].tx: %d", pan.pn, mv[pan.pn].tx); printf("	mv[%u].ty: %d	", pan.pn, mv[pan.pn].ty);
src/scroll.c:	//0000printf("\ngvar.video.tickclk=%f\n", gvar.video.tickclk);
src/scroll.c:	//0000printf("gvar.video.clk=%f", gvar.video.clk);
src/scroll.c:	//printf("map.width=%d	map.height=%d	map.data[0]=%d\n", mv[0].map->width, mv[0].map->height, mv[0].map->data[0]);
src/sountest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/sountest.c://#include "src/lib/16_snd.h"
src/sountest.c://	static FMInstrument testInst =
src/sountest.c://{
src/sountest.c://0x00, 0x01,	/* modulator frequency multiple... 0x20 */
src/sountest.c://0x00, 0x00,	/* modulator frequency level...    0x40 */
src/sountest.c://0xF0, 0xF0,	/* modulator attack/decay...       0x60 */
src/sountest.c://0x73, 0x73,	/* modulator sustain/release...    0x80 */
src/sountest.c://0x03, 0x00,	/* output waveform distortion      0xE0 */
src/sountest.c://0x36,				/* feedback algorithm and strength 0xC0 */
src/sountest.c://};
src/sountest.c:	//FMReset();
src/sountest.c:	//FMSetVoice(0, &testInst);
src/sountest.c://		vga_bios_set_80x50_text();
src/sountest.c:			//FMKeyOn(0, 0x106, 4);
src/sountest.c:			//FMKeyOff(0);
src/test0.c:// 	w = _nmalloc(sizeof(unsigned));
src/test2.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/test2.c://#include "src/lib/bitmap.h"
src/test2.c://----    planar_buf_t *p;
src/test2.c:    //byte color;
src/test2.c://	file = fopen("ptmp0.pcx", "wb");
src/test2.c:    //fwrite(p, 1, p->width*p->height, file);
src/test2.c:    //fclose(file);
src/test.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/test.c:	//argument
src/test.c:	// DOSLIB: check our environment
src/test.c:	// DOSLIB: what CPU are we using?
src/test.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/test.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/test.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/test.c:	//      the CPU to carry out tasks. --J.C.
src/test.c:	// DOSLIB: check for VGA
src/test.c:	// hardware must be VGA or higher!
src/test.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/test.c:	//modexPalOverscan(44+1);
src/test.c://  	gvar.video.page[0]=modexDefaultPage(&gvar.video.page[0]);
src/test.c://  	gvar.video.page[1] = modexNextPage(&gvar.video.page[0]);
src/test.c:				// go right
src/test.c:				// go left
src/test.c:				// go up
src/test.c:				// go down
src/test.c:// 			if(IN_KeyDown(6))
src/test.c:// 			{
src/test.c:// 				modexClearRegion(&gvar.video.page[1],  gvar.video.page[1].sw, 16, 8, 4, 45);
src/test.c:// 			}
src/test.c:// 			if(IN_KeyDown(4+1)){
src/test.c:// 				modexClearRegion(&gvar.video.page[1], 16, 16, gvar.video.page[1].sw, gvar.video.page[1].sh, 128);
src/test.c:// 				modexClearRegion(&gvar.video.page[1], 32, 32, gvar.video.page[1].sw-32, gvar.video.page[1].sh-32, 42);
src/test.c:// 				modexClearRegion(&gvar.video.page[1], 48, 48, gvar.video.page[1].sw-64, gvar.video.page[1].sh-64, 128);
src/test.c:// 			}
src/test.c:		//}
src/test.c://			if(i>PAL_SIZE) i=0;
src/test.c:		}//9
src/test.c:		}//p
src/testemm0.c://#include "src/lib/doslib/cpu.h"
src/testemm0.c://#include <hw/dos/doswin.h>
src/testemm0.c://		printf("Allocating EMM pages (1.6MB): ");
src/testemm0.c:		//h2 = emm_alloc_pages(0x19999AUL >> 14UL);
src/testemm0.c:		//printf("Allocating EMM pages (12MB): ");
src/testemm0.c:		//h3 = emm_alloc_pages(0xC00000UL >> 14UL);
src/testemm.c://#include "src/lib/doslib/cpu.h"
src/testemm.c://#include <hw/dos/doswin.h>
src/tesuto.c:	vga_enable_256color_modex(); // VGA mode X
src/tesuto.c:	vga_state.vga_width = 320; // VGA lib currently does not update this
src/tesuto.c:	vga_state.vga_height = 240; // VGA lib currently does not update this
src/tesuto.c:#if 1 // 320x240 test mode: this is how Project 16 is using our code, enable for test case
src/tesuto.c:		// 320x240 mode 60Hz
src/tesuto.c:	vga_state.vga_height = 240; // VGA lib currently does not update this
src/tesuto.c:				vga_state.vga_graphics_ram[o] = (i^j)&15; // VRL samples put all colors in first 15!
src/tesuto.c:	//while (getch() != 13);
src/tesuto.c:		unsigned int overdraw = 1;	// how many pixels to "overdraw" so that moving sprites with edge pixels don't leave streaks.
src/tesuto.c:						// if the sprite's edge pixels are clear anyway, you can set this to 0.
src/tesuto.c:		omemptr = vga_state.vga_graphics_ram; // save original mem ptr
src/tesuto.c:					vga_state.vga_graphics_ram[o] = (i^j)&15; // VRL samples put all colors in first 15!
src/tesuto.c:			o = offscreen_ofs; // source offscreen
src/tesuto.c:			o2 = (ry * vga_state.vga_stride) + (rx >> 2); // dest visible (original stride)
src/tesuto.c:		unsigned int overdraw = 1;	// how many pixels to "overdraw" so that moving sprites with edge pixels don't leave streaks.
src/tesuto.c:						// if the sprite's edge pixels are clear anyway, you can set this to 0.
src/tesuto.c:				vga_state.vga_graphics_ram[o] = (i^j)&15; // VRL samples put all colors in first 15!
src/tesuto.c:		omemptr = vga_state.vga_graphics_ram; // save original mem ptr
src/tesuto.c:			o = pattern_ofs + (ry * vga_state.vga_stride) + (rx >> 2); // source offscreen
src/tesuto.c:			o = offscreen_ofs; // source offscreen
src/tesuto.c:			o2 = (ry * vga_state.vga_stride) + (rx >> 2); // dest visible (original stride)
src/tesuto.c:			dstart = (vga_state.vga_height - dh) / 2; // center the squash effect on screen, otherwise it would squash to top of screen
src/tesuto.h://VGA_RAM_PTR vga_graphics_ram = (VGA_RAM_PTR)MK_FP(0xA000,0x0000);
src/tesuto.h://unsigned char vga_stride = 80; // 80 x 4 = 320 for 320-pixel wide modes
src/tsthimem.c://#include "src/lib/doslib/cpu.h"
src/tsthimem.c://#include doswin.h>
src/vgacamm.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/vgacamm.c:	// DOSLIB: check our environment
src/vgacamm.c:	// DOSLIB: what CPU are we using?
src/vgacamm.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/vgacamm.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/vgacamm.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/vgacamm.c:	//      the CPU to carry out tasks. --J.C.
src/vgacamm.c:	// DOSLIB: check for VGA
src/vgacamm.c:	// hardware must be VGA or higher!
src/vgacamm.c:	//
src/vgacamm.c:	//
src/vgacamm.c:	//printf("CPU to VGA: %f\n", t1);
src/vgacamm.c:	//printf("VGA to VGA: %f\n", t2);
src/vgacamm.c:// 	printf("Num %d", num_of_vrl);
src/vgmtest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/vgmtest.c://#include "src/lib/doslib/adlib.h"
src/vgmtest.c:	//ym3812_w(0, 0, reg);
src/vgmtest.c:	//ym3812_w(0, 1, data);
src/vgmtest.c:	//return ym3812_r(0, 0);
src/vgmtest.c:	//++++global_game_variables_t gvar;
src/vgmtest.c:	//while(!kbhit())
src/vrstest.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/vrstest.c://#include "src/lib/16_head.h"
src/vrstest.c:	//__segment sega;
src/vrstest.c:	//vrl1_vgax_offset_t * off, *off1;
src/vrstest.c:	// DOSLIB: check our environment
src/vrstest.c:	// DOSLIB: what CPU are we using?
src/vrstest.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/vrstest.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/vrstest.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/vrstest.c:	//      the CPU to carry out tasks. --J.C.
src/vrstest.c:	// DOSLIB: check for VGA
src/vrstest.c:	// hardware must be VGA or higher!
src/vrstest.c:	//gvar.video.page[0]=modexDefaultPage(&gvar.video.page[0]);
src/vrstest.c:	// What should be done by read_vrs:
src/vrstest.c:	//sega = (mm.bufferseg);
src/vrstest.c:	// Insert sanity cheks later
src/vrstest.c:	// Allocate memory for vrl line offsets table
src/vrstest.c:	// Calculate line offsets for each vrl
src/vrstest.c:		// Calc. vrl size as (next_offset - curr_offset)
src/vrstest.c:		// If it's the last vrl, size is (next_vrs_struct_offset - curr_offset)
src/vrstest.c:	//read_vrs(&gvar, "data/spri/chikyuu.vrs", &vrs);
src/vrstest.c://	Uncomment to see broken sprites
src/vrstest.c:	//MM_FreePtr(&((void __based(sega)*)spri.spritesheet->buffer), &mm);
src/vrstest.c:	//printf("CPU to VGA: %f\n", t1);
src/vrstest.c:	//printf("VGA to VGA: %f\n", t2);
src/vrstest.c://0000	printf("gvar.video.page[0].width: %u\n", gvar.video.page[0].width);
src/vrstest.c://0000	printf("gvar.video.page[0].height: %u\n", gvar.video.page[0].height);
src/zcroll.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/zcroll.c://debugswitches
src/zcroll.c://extern boolean pageflipflop=1;
src/zcroll.c://static int persist_aniframe = 0;    /* gonna be increased to 1 before being used, so 0 is ok for default */
src/zcroll.c://map_view_db_t pgid[4];
src/zcroll.c://#ifdef FADE
src/zcroll.c://#endif
src/zcroll.c:	// OK, this one takes hellova time and needs to be done in farmalloc or MM_...
src/zcroll.c:	// create the map
src/zcroll.c://goto pee;
src/zcroll.c:	// data
src/zcroll.c:	//	input!
src/zcroll.c:	// save the palette
src/zcroll.c:	modexPalBlack();	//reset the palette~
src/zcroll.c:	modexPalBlack();	//so player will not see loadings~
src/zcroll.c:	// setup camera and screen~
src/zcroll.c:	// set up paging
src/zcroll.c:	//TODO: LOAD map data and position the map in the middle of the screen if smaller then screen
src/zcroll.c:	//_fmemcpy(mv[1].page->data, mv->page->data, mv->page->pagesize);
src/zcroll.c:	//TODO: put player in starting position of spot
src/zcroll.c:	//default player position on the viewable map
src/zcroll.c:	//IN_initplayer(&player, 1);
src/zcroll.c:// #ifndef	SPRITE
src/zcroll.c:// 	modexClearRegion(mv->page, player->x, player->y-TILEWH, 16, 32, 15);
src/zcroll.c:// 	//modexClearRegion(mv[1].page, player->x, player->y-TILEWH, 16, 32, 15);
src/zcroll.c:// #else
src/zcroll.c:// 	//PBUFSFUN(mv[1].page, player->x, player->y-TILEWH, 16, 64, 24, 32,	PLAYERBMPDATA);
src/zcroll.c:// //	PBUFSFUN(mv->page, player->x, player->y-TILEWH, 16, 64, 16, 32,	player->data);
src/zcroll.c:	//animate_spri(&(player->ent->spri));
src/zcroll.c:// #endif
src/zcroll.c:	modexShowPage(mv->page);//!(gvar.video.p)
src/zcroll.c:	shinku_fps_indicator_page = 0; // we're on page 1 now, shinku(). follow along please or it will not be visible.
src/zcroll.c:	// buffer pages
src/zcroll.c:// 	modexClearRegion(mv[2].page, 0, 0, mv[2].page->width, mv[2].page->height, 47);
src/zcroll.c:// 	modexClearRegion(mv[3].page, 0, 0, mv[3].page->width, mv[3].page->height, 45);
src/zcroll.c:// 	{
src/zcroll.c:// 		unsigned int k,j,o;
src/zcroll.c:// 		// fill screen with a distinctive pattern
src/zcroll.c:// 		for (k=0;k < vga_state.vga_width;k++) {
src/zcroll.c:// 			o = k >> 2;
src/zcroll.c:// 			vga_write_sequencer(0x02/*map mask*/,1 << (k&3));
src/zcroll.c:// 				for (j=0;j < vga_state.vga_height;j++,o += vga_state.vga_stride)
src/zcroll.c:// 					vga_state.vga_graphics_ram[o] = (k^j)&15; // VRL samples put all colors in first 15!
src/zcroll.c:// 		}
src/zcroll.c:// 	}
src/zcroll.c://	modexFadeOn(4, gpal);*/
src/zcroll.c:		//top left corner & bottem right corner of map veiw be set as map edge trigger since maps are actually square
src/zcroll.c:		//to stop scrolling and have the player position data move to the edge of the screen with respect to the direction
src/zcroll.c:		//when player->tx or player->ty == 0 or player->tx == 20 or player->ty == 15 then stop because that is edge of map and you do not want to walk of the map
src/zcroll.c:		//player movement
src/zcroll.c:		//the scripting stuff....
src/zcroll.c:*/		//debugging binds!
src/zcroll.c:		}	//p
src/zcroll.c:		//pan switch
src/zcroll.c:		if(IN_KeyDown(88)){panswitch=!panswitch; IN_UserInput(1,1);}	//f12
src/zcroll.c:		if(IN_KeyDown(87))	//f11
src/zcroll.c:		if(IN_KeyDown(68))	//f10
src/zcroll.c:		if(IN_KeyDown(67))	//f9
src/zcroll.c:		if(IN_KeyDown(66))	//f8
src/zcroll.c:	//		modexDrawSprite(mv->page, 16, 16, p);
src/zcroll.c:		//TODO fmemtest into page
src/zcroll.c:		/*if(IN_KeyDown(4+1))	//4
src/zcroll.c:		//9
src/zcroll.c:		//if(IN_KeyDown(11)){ modexPalOverscan(15); }
src/zcroll.c:		if((player->q==1) && !(player->x%TILEWH==0 && player->y%TILEWH==0)) break;	//incase things go out of sync!
src/zcroll.c://pee:
src/zcroll.c:	//if(player->hp==0) printf("%d wwww\n", player->y+8);
src/zcroll.c:	//else printf("\nplayer->y: %d\n", player->y);
src/zcroll.c:	//printf("mv[%u].tx: %d", pan.pn, mv[pan.pn].tx); printf("	mv[%u].ty: %d	", pan.pn, mv[pan.pn].ty);
src/zcroll.c:	//0000printf("\ngvar.video.tickclk=%f\n", gvar.video.tickclk);
src/zcroll.c:	//0000printf("gvar.video.clk=%f", gvar.video.clk);
src/zcroll.c:	//printf("map.width=%d	map.height=%d	map.data[0]=%d\n", mv->map->width, mv->map->height, mv->map->data[0]);
src/lib/16_ca.c:// ID_CA.C
src/lib/16_ca.c://#define THREEBYTEGRSTARTS
src/lib/16_ca.c://https://github.com/open-watcom/open-watcom-v2/issues/279#issuecomment-244587566 for _seg
src/lib/16_ca.c:  word bit0,bit1;	// 0-255 is a character, > is a pointer to a node
src/lib/16_ca.c:long		_seg *grstarts;	// array of offsets in egagraph, -1 for sparse
src/lib/16_ca.c:long		_seg *audiostarts;	// array of offsets in audio / audiot
src/lib/16_ca.c:int			grhandle;		// handle to EGAGRAPH
src/lib/16_ca.c:int			maphandle;		// handle to MAPTEMP / GAMEMAPS
src/lib/16_ca.c:int			audiohandle;	// handle to AUDIOT / AUDIO
src/lib/16_ca.c://void	CAL_CarmackExpand (unsigned far *source, unsigned far *dest,unsigned length);
src/lib/16_ca.c://#define	GRFILEPOS(c) (*(long far *)(((byte far *)grstarts)+(c)*3)&0xffffff)
src/lib/16_ca.c:	//dword fat=0;
src/lib/16_ca.c:	//word segm=0;
src/lib/16_ca.c:		//segm=(length%0xfffflu)-1;
src/lib/16_ca.c:		//fat=segm*0xfffflu;
src/lib/16_ca.c:		//length-=fat;
src/lib/16_ca.c:		return 0;//TODO: EXPAND!!!
src/lib/16_ca.c:	//if(!fat&&!segm)
src/lib/16_ca.c:	//{
src/lib/16_ca.c:		mov	ah,0x3f				// READ w/handle
src/lib/16_ca.c://		errno = EINVFMT;			// user manager knows this is bad read
src/lib/16_ca.c:	//dword fat=0;
src/lib/16_ca.c:	//word segm=0;
src/lib/16_ca.c:		//segm=(length%0xfffflu)-1;
src/lib/16_ca.c:		//fat=segm*0xfffflu;
src/lib/16_ca.c:		//length-=fat;
src/lib/16_ca.c:	//if(!fat&&!segm)
src/lib/16_ca.c:	//{
src/lib/16_ca.c:		mov	ah,0x40			// WRITE w/handle
src/lib/16_ca.c://		errno = ENOMEM;				// user manager knows this is bad write
src/lib/16_ca.c:	//long size;
src/lib/16_ca.c:	//sdword size;
src/lib/16_ca.c:	//long size;
src/lib/16_ca.c:	//long size;
src/lib/16_ca.c://  unsigned bit,byte,node,code;
src/lib/16_ca.c://  huffnode *nodeon;
src/lib/16_ca.c:	headptr = hufftable+254;	// head node is allways node 254
src/lib/16_ca.c:  source++;	// normalize
src/lib/16_ca.c://
src/lib/16_ca.c:// ds:si source
src/lib/16_ca.c:// es:di dest
src/lib/16_ca.c:// ss:bx node pointer
src/lib/16_ca.c://
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c:// expand less than 64k of data
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c:		mov	ch,[si]				// load first byte
src/lib/16_ca.c:		test	ch,cl			// bit set?
src/lib/16_ca.c:		mov	dx,[ss:bx]			// take bit0 path from node
src/lib/16_ca.c:		shl	cl,1				// advance to next bit position
src/lib/16_ca.c:		mov	dx,[ss:bx+2]		// take bit1 path
src/lib/16_ca.c:		shl	cl,1				// advance to next bit position
src/lib/16_ca.c:		mov	ch,[si]				// load next byte
src/lib/16_ca.c:		mov	cl,1				// back to first bit
src/lib/16_ca.c:		or	dh,dh				// if dx<256 its a byte, else move node
src/lib/16_ca.c:		mov	bx,dx				// next node = (huffnode *)code
src/lib/16_ca.c:		inc	di					// write a decopmpressed byte out
src/lib/16_ca.c:		mov	bx,[word ptr headptr]		// back to the head node for next bit
src/lib/16_ca.c:		cmp	di,ax				// done?
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c:// expand more than 64k of data
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c:		lodsb			// load first byte
src/lib/16_ca.c:		test	al,cl		// bit set?
src/lib/16_ca.c:		mov	dx,[ss:bx]	// take bit0 path from node
src/lib/16_ca.c:		mov	dx,[ss:bx+2]	// take bit1 path
src/lib/16_ca.c:		shl	cl,1		// advance to next bit position
src/lib/16_ca.c:		cmp	si,0x10		// normalize ds:si
src/lib/16_ca.c:		mov	cl,1		// back to first bit
src/lib/16_ca.c:		or	dh,dh		// if dx<256 its a byte, else move node
src/lib/16_ca.c:		mov	bx,dx		// next node = (huffnode *)code
src/lib/16_ca.c:		inc	di		// write a decopmpressed byte out
src/lib/16_ca.c:		mov	bx,[word ptr headptr]	// back to the head node for next bit
src/lib/16_ca.c:		cmp	di,0x10		// normalize es:di
src/lib/16_ca.c:		jns	expand		// when length = ffff ffff, done
src/lib/16_ca.c:			{				// have to insert a word containing the tag byte
src/lib/16_ca.c:			{				// have to insert a word containing the tag byte
src/lib/16_ca.c://
src/lib/16_ca.c:// compress it
src/lib/16_ca.c://
src/lib/16_ca.c:    //
src/lib/16_ca.c:    // send a tag / count / value string
src/lib/16_ca.c:    //
src/lib/16_ca.c:    //
src/lib/16_ca.c:    // send word without compressing
src/lib/16_ca.c:    //
src/lib/16_ca.c://  unsigned value,count,i;
src/lib/16_ca.c://
src/lib/16_ca.c:// expand it
src/lib/16_ca.c://
src/lib/16_ca.c:	//
src/lib/16_ca.c:	// uncompressed
src/lib/16_ca.c:	//
src/lib/16_ca.c:	//
src/lib/16_ca.c:	// compressed string
src/lib/16_ca.c:	//
src/lib/16_ca.c://
src/lib/16_ca.c:// ax = source value
src/lib/16_ca.c:// bx = tag value
src/lib/16_ca.c:// cx = repeat counts
src/lib/16_ca.c:// dx = scratch
src/lib/16_ca.c://
src/lib/16_ca.c:// NOTE: A repeat count that produces 0xfff0 bytes can blow this!
src/lib/16_ca.c://
src/lib/16_ca.c:		mov	cx,ax		// repeat count
src/lib/16_ca.c:		lodsw			// repeat value
src/lib/16_ca.c:		cmp	si,0x10		// normalize ds:si
src/lib/16_ca.c:		cmp	di,0x10		// normalize es:di
src/lib/16_ca.c:////++++ enable!
src/lib/16_ca.c://
src/lib/16_ca.c:// load ???dict.ext (huffman dictionary for graphics files)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// load the data offsets from ???head.ext
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// Open the graphics file, leaving it open until the game is finished
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// load the pic and sprite headers into the arrays in the data segment
src/lib/16_ca.c://
src/lib/16_ca.c:	CAL_GetGrChunkLength(STRUCTPIC);		// position file pointer
src/lib/16_ca.c:	CAL_GetGrChunkLength(STRUCTPICM);		// position file pointer
src/lib/16_ca.c:	CAL_GetGrChunkLength(STRUCTSPRITE);	// position file pointer
src/lib/16_ca.c://==========================================================================
src/lib/16_ca.c:// 	int handle;
src/lib/16_ca.c:// 	long length;
src/lib/16_ca.c://
src/lib/16_ca.c:// load maphead.ext (offsets and tileinfo for map file)
src/lib/16_ca.c://
src/lib/16_ca.c:// #ifndef MAPHEADERLINKED
src/lib/16_ca.c:// 	if ((handle = open("MAPHEAD."EXT,
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:// 		printf("Can't open MAPHEAD."EXT"!");
src/lib/16_ca.c:// 	length = filelength(handle);
src/lib/16_ca.c:// 	MM_GetPtr (&(memptr)tinf,length);
src/lib/16_ca.c:// 	CA_FarRead(handle, tinf, length);
src/lib/16_ca.c:// 	close(handle);
src/lib/16_ca.c:// //#else
src/lib/16_ca.c://
src/lib/16_ca.c:// 	tinf = (byte _seg *)FP_SEG(&maphead);
src/lib/16_ca.c://
src/lib/16_ca.c:// #endif
src/lib/16_ca.c://
src/lib/16_ca.c:// open the data file
src/lib/16_ca.c://
src/lib/16_ca.c://TODO: multiple files
src/lib/16_ca.c:// #ifdef MAPHEADERLINKED
src/lib/16_ca.c:// 	if ((maphandle = open("GAMEMAPS."EXT,
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:// 		Quit ("Can't open GAMEMAPS."EXT"!");
src/lib/16_ca.c:// //#else
src/lib/16_ca.c:// 	if ((maphandle = open("MAPTEMP."EXT,
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:// 		Quit ("Can't open MAPTEMP."EXT"!");
src/lib/16_ca.c:// #endif
src/lib/16_ca.c://==========================================================================
src/lib/16_ca.c://
src/lib/16_ca.c:// load maphead.ext (offsets and tileinfo for map file)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// open the data file
src/lib/16_ca.c://
src/lib/16_ca.c://==========================================================================
src/lib/16_ca.c:#endif//profile
src/lib/16_ca.c://==========================================================================
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c:		return;							// allready in memory
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// MDM end
src/lib/16_ca.c://
src/lib/16_ca.c:// load the chunk into a buffer, either the miscbuffer if it fits, or allocate
src/lib/16_ca.c:// a larger buffer
src/lib/16_ca.c://
src/lib/16_ca.c:	source += 4;			// skip over length
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c:			MM_SetPurge (&(memptr)audiosegs[start],3);		// make purgable
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://++++#if GRMODE == EGAGR
src/lib/16_ca.c:	sheight = height;		// because we are going to reassign bp
src/lib/16_ca.c:asm	mov	ds,ax		// source and dest are in same segment, and all local
src/lib/16_ca.c:asm	mov	bp,WORD PTR [shifttabletable+bp]	// bp holds pointer to shift table
src/lib/16_ca.c://
src/lib/16_ca.c:// table shift the mask
src/lib/16_ca.c://
src/lib/16_ca.c:asm	mov	BYTE PTR [di],255	// 0xff first byte
src/lib/16_ca.c:asm	mov	al,[bx]				// source
src/lib/16_ca.c:asm	inc	bx					// next source byte
src/lib/16_ca.c:asm	mov	ax,[bp+si]			// table shift into two bytes
src/lib/16_ca.c:asm	and	[di],al				// and with first byte
src/lib/16_ca.c:asm	mov	[di],ah				// replace next byte
src/lib/16_ca.c:asm	inc	di					// the last shifted byte has 1s in it
src/lib/16_ca.c://
src/lib/16_ca.c:// table shift the data
src/lib/16_ca.c://
src/lib/16_ca.c:asm	shl	dx,1				// four planes of data
src/lib/16_ca.c:asm	mov	BYTE PTR [di],0		// 0 first byte
src/lib/16_ca.c:asm	mov	al,[bx]				// source
src/lib/16_ca.c:asm	inc	bx					// next source byte
src/lib/16_ca.c:asm	mov	ax,[bp+si]			// table shift into two bytes
src/lib/16_ca.c:asm	or	[di],al				// or with first byte
src/lib/16_ca.c:asm	mov	[di],ah				// replace next byte
src/lib/16_ca.c:asm	inc	di					// the last shifted byte has 0s in it
src/lib/16_ca.c://
src/lib/16_ca.c:// done
src/lib/16_ca.c://
src/lib/16_ca.c:asm	mov	ax,ss				// restore data segment
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://
src/lib/16_ca.c:// CGA has no pel panning, so shifts are never needed
src/lib/16_ca.c://
src/lib/16_ca.c:	dest->sourceoffset[0] = MAXSHIFTS*6;	// start data after 3 unsigned tables
src/lib/16_ca.c://
src/lib/16_ca.c:// expand the unshifted shape
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// calculate sizes
src/lib/16_ca.c://
src/lib/16_ca.c:	shiftstarts[0] = MAXSHIFTS*6;	// start data after 3 unsigned tables
src/lib/16_ca.c:	shiftstarts[1] = shiftstarts[0] + smallplane*5;	// 5 planes in a sprite
src/lib/16_ca.c:	shiftstarts[4] = shiftstarts[3] + bigplane*5;	// nothing ever put here
src/lib/16_ca.c://
src/lib/16_ca.c:// expand the unshifted shape
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// make the shifts!
src/lib/16_ca.c://
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c:	//
src/lib/16_ca.c:	// expanded sizes of tile8/16/32 are implicit
src/lib/16_ca.c:	//
src/lib/16_ca.c:		if (chunk<STARTTILE8M)			// tile 8s are all in one chunk!
src/lib/16_ca.c:		else if (chunk<STARTTILE16M)	// all other tiles are one/chunk
src/lib/16_ca.c:	//
src/lib/16_ca.c:	// everything else has an explicit size longword
src/lib/16_ca.c:	//
src/lib/16_ca.c:		source += 4;			// skip over length
src/lib/16_ca.c://
src/lib/16_ca.c:// allocate final space, decompress it, and free bigbuffer
src/lib/16_ca.c:// Sprites need to have shifts made and various other junk
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// load the chunk into a buffer, either the miscbuffer if it fits, or allocate
src/lib/16_ca.c:// a larger buffer
src/lib/16_ca.c://
src/lib/16_ca.c:	if (pos<0)							// $FFFFFFFF start is a sparse tile
src/lib/16_ca.c:	while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c:	gvar->video.grneeded[chunk] |= ca_levelbit;		// make sure it doesn't get removed
src/lib/16_ca.c:		return;							// allready in memory
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// MDM end
src/lib/16_ca.c://
src/lib/16_ca.c:// load the chunk into a buffer, either the miscbuffer if it fits, or allocate
src/lib/16_ca.c:// a larger buffer
src/lib/16_ca.c://
src/lib/16_ca.c:	if (pos<0)							// $FFFFFFFF start is a sparse tile
src/lib/16_ca.c:	while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c://==========================================================================
src/lib/16_ca.c://
src/lib/16_ca.c:// free up memory from last map
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// load map header
src/lib/16_ca.c:// The header will be cached if it is still around
src/lib/16_ca.c://
src/lib/16_ca.c:		//pos = ((mapfiletype	_seg *)tinf)->headeroffsets[mapnum];
src/lib/16_ca.c:		if (pos<0)						// $FFFFFFFF start is a sparse map
src/lib/16_ca.c://
src/lib/16_ca.c:// load the planes in
src/lib/16_ca.c:// If a plane's pointer still exists it will be overwritten (levels are
src/lib/16_ca.c:// allways reloaded, never cached)
src/lib/16_ca.c://
src/lib/16_ca.c:			continue;		// the plane is not used in this game
src/lib/16_ca.c:		//
src/lib/16_ca.c:		// unhuffman, then unRLEW
src/lib/16_ca.c:		// The huffman'd chunk has a two byte expanded length first
src/lib/16_ca.c:		// The resulting RLEW chunk also does, even though it's not really
src/lib/16_ca.c:		// needed
src/lib/16_ca.c:		//
src/lib/16_ca.c:		//
src/lib/16_ca.c:		// unRLEW, skipping expanded length
src/lib/16_ca.c:		//
src/lib/16_ca.c:}//*/
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c:	////++++++++++++++++++++++++++++++++++++++++++CA_CacheMarks(NULL);
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://
src/lib/16_ca.c:// free graphics
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// free cursor sprite and background save
src/lib/16_ca.c://
src/lib/16_ca.c:	//VW_FreeCursor ();
src/lib/16_ca.c://
src/lib/16_ca.c:// free map headers and map planes
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// free sounds
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// free graphics
src/lib/16_ca.c://
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c://
src/lib/16_ca.c:// draw dialog window (masked tiles 12 - 20 are window borders)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// draw thermometer bar
src/lib/16_ca.c://
src/lib/16_ca.c:	VWB_DrawTile8(thx,thy,0);		// CAT3D numbers
src/lib/16_ca.c:	thx += 4;		// first line location
src/lib/16_ca.c://===========================================================================
src/lib/16_ca.c:*//*
src/lib/16_ca.c:	long	bufferstart,bufferend;	// file position of general buffer
src/lib/16_ca.c://
src/lib/16_ca.c:// go through and make everything not needed purgable
src/lib/16_ca.c://
src/lib/16_ca.c:			if (grsegs[i])					// its allready in memory, make
src/lib/16_ca.c:				MM_SetPurge(&grsegs[i],0);	// sure it stays there!
src/lib/16_ca.c:			if (grsegs[i])					// not needed, so make it purgeable
src/lib/16_ca.c:	if (!numcache)			// nothing to cache!
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c://
src/lib/16_ca.c://
src/lib/16_ca.c:// MDM end
src/lib/16_ca.c://
src/lib/16_ca.c:// go through and load in anything still needed
src/lib/16_ca.c://
src/lib/16_ca.c:	bufferstart = bufferend = 0;		// nothing good in buffer now
src/lib/16_ca.c://
src/lib/16_ca.c:// update thermometer
src/lib/16_ca.c://
src/lib/16_ca.c:			while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c:				// data is allready in buffer
src/lib/16_ca.c:				// load buffer with a new block from disk
src/lib/16_ca.c:				// try to get as many of the needed blocks in as possible
src/lib/16_ca.c:						while (GRFILEPOS(++next) == -1)	// skip past any sparse tiles
src/lib/16_ca.c:							next = NUMCHUNKS;			// read pos to posend
src/lib/16_ca.c:			// big chunk, allocate temporary buffer
src/lib/16_ca.c://
src/lib/16_ca.c:// finish up any thermometer remnants
src/lib/16_ca.c://
src/lib/16_ca.h:// ID_CA.H
src/lib/16_ca.h://===========================================================================
src/lib/16_ca.h://#define NOMAPS
src/lib/16_ca.h://#define NOGRAPHICS
src/lib/16_ca.h://#define NOAUDIO
src/lib/16_ca.h://#define MAPHEADERLINKED
src/lib/16_ca.h://#define GRHEADERLINKED
src/lib/16_ca.h://#define AUDIOHEADERLINKED
src/lib/16_ca.h://#define NUMMAPS		39
src/lib/16_ca.h://#define MAPPLANES		3
src/lib/16_ca.h://++++#define PROFILE//++++
src/lib/16_ca.h://===========================================================================
src/lib/16_ca.h://===========================================================================
src/lib/16_ca.h://extern
src/lib/16_ca.h://
src/lib/16_ca.h:// hooks for custom cache dialogs
src/lib/16_ca.h://
src/lib/16_ca.h://===========================================================================
src/lib/16_ca.h:// just for the score box reshifting
src/lib/16_ca.h://void CAL_ShiftSprite (unsigned segment,unsigned source,unsigned dest,unsigned width, unsigned height, unsigned pixshift, boolean domask);
src/lib/16_ca.h://===========================================================================
src/lib/16_ca.h://void CA_CacheAudioChunk (int chunk);
src/lib/16_ca.h://void CA_LoadAllSounds (void);
src/lib/16_dbg.c:// TODO: Could we also provide a build mode to emit debug to the "Bochs E9 hack?"
src/lib/16_dbg.c:		// what does the BIOS say the serial ports are?
src/lib/16_dbg.c:		// what about the standard serial ports?
src/lib/16_dbg.c:		// pick the first port, which is probably COM1
src/lib/16_dbg.c:		if (base_8250_ports == 0) return 0; // FIXME: You know "base_8250_ports" is probably a bad variable name for the max entries in info_8250_port[]
src/lib/16_dbg.c:		// init the COM port.
src/lib/16_dbg.c:		// in DOSBox-X, the "log" mode will receive our text and print it into the log file
src/lib/16_dbg.c:		// on real hardware, our text will likely go over a null modem cable to another PC running a serial terminal program like PuTTY or minicom.
src/lib/16_dbg.c:		// if nothing is connected, then the bytes go off into the ether to get lost and life goes on.
src/lib/16_dbg.c:		uart_8250_enable_interrupt(_DEBUG_uart,0);	// disable interrupts
src/lib/16_dbg.c:		uart_8250_set_FIFO(_DEBUG_uart,0x07);		// enable FIFO (why not?), also clear xmit/recv FIFO buffers, set threshhold to 1 byte
src/lib/16_dbg.c:		uart_8250_set_MCR(_DEBUG_uart,3);		// RTS and DTS on
src/lib/16_dbg.c:		uart_8250_set_line_control(_DEBUG_uart,UART_8250_LCR_8BIT | UART_8250_LCR_PARITY); // 8 bit 1 stop bit odd parity
src/lib/16_dbg.c:		uart_8250_set_baudrate(_DEBUG_uart,uart_8250_baud_to_divisor(_DEBUG_uart,9600)); // 9600 baud
src/lib/16_dbg.c:			while (!uart_8250_can_write(_DEBUG_uart)); // wait for the UART to indicate readiness for our output
src/lib/16_dbg.c:			uart_8250_write(_DEBUG_uart,(uint8_t)c); // then write it
src/lib/16_dbg.h://#define __DEBUG_PM__
src/lib/16_dbg.h://#define __DEBUG_MM__
src/lib/16_dbg.h:	// NOTHING
src/lib/16_dbg.h:	// NOTHING
src/lib/16_dbg.h:	// NOTHING
src/lib/16_dbg.h:#endif // _SRC_LIB_16_DBG
src/lib/16_enti.h:	int x; // exact position on the viewable map
src/lib/16_enti.h:	int y; // exact position on the viewable map
src/lib/16_enti.h:	int tx; // tile position on the viewable map
src/lib/16_enti.h:	int ty; // tile position on the viewable map
src/lib/16_enti.h:	int triggerx; // trigger box tile position on the viewable map
src/lib/16_enti.h:	int triggery; // trigger box tile position on the viewable map
src/lib/16_enti.h:	byte d;		// direction the NPC faces
src/lib/16_enti.h:	struct sprite *spri; // sprite used by NPC
src/lib/16_enti.h:	sword hp; // hitpoints of the NPC
src/lib/16_enti.h:	byte near pdir;	// previous direction~
src/lib/16_enti.h:	word speed;		// NPC's speed
src/lib/16_enti.h:	word spt;		// speed per tile
src/lib/16_hc.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_hc.c:	// allocate based heap
src/lib/16_hc.c:		//exit( 1 );
src/lib/16_hc.c:	//near
src/lib/16_hc.c:	//far
src/lib/16_hc.c:			//printf("OK - end of heap\n");
src/lib/16_hc.c:			//printf("OK - heap is empty\n");
src/lib/16_hc.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_hc.h://void __based(__self)* LargestBasedFreeBlock(size_t* Size);
src/lib/16_hc.h://size_t _basedcoreleft(void);
src/lib/16_head.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_head.c:	if(strlen(str)<=4) strcat(strc,"	"); //printf("%u\n", strlen(str));
src/lib/16_head.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_head.c://
src/lib/16_head.c://      US_CheckParm() - checks to see if a string matches one of a set of
src/lib/16_head.c://              strings. The check is case insensitive. The routine returns the
src/lib/16_head.c://              index of the string that matched, or -1 if no matches were found
src/lib/16_head.c://
src/lib/16_head.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_head.c:	while (!isalpha(*parm)) // Skip non-alphas
src/lib/16_head.c://===========================================================================
src/lib/16_head.c:	//ClearMemory ();
src/lib/16_head.c:	 //WriteConfig ();
src/lib/16_head.c:	 //CA_CacheGrChunk (ERRORSCREEN);
src/lib/16_head.c:	 //screen = grsegs[ERRORSCREEN];
src/lib/16_head.c:	//ShutdownId ();
src/lib/16_head.c:	//IN_Shutdown();
src/lib/16_head.c:	//modexLeave();
src/lib/16_head.c:	  //movedata ((unsigned)screen,7,0xb800,0,7*160);
src/lib/16_head.c:	  //gotoxy (10,4);
src/lib/16_head.c:	  //gotoxy (1,8);
src/lib/16_head.c:		//clrscr();
src/lib/16_head.c:		//#ifndef JAPAN
src/lib/16_head.c:		//gotoxy(1,24);
src/lib/16_head.c:		//#endif
src/lib/16_head.c://asm	mov	bh,0
src/lib/16_head.c://asm	mov	dh,23	// row
src/lib/16_head.c://asm	mov	dl,0	// collumn
src/lib/16_head.c://asm	mov ah,2
src/lib/16_head.c://asm	int	0x10
src/lib/16_head.c://===========================================================================
src/lib/16_head.c:		case 0: //up
src/lib/16_head.c:		case 4: //down
src/lib/16_head.c:		case 1: //left
src/lib/16_head.c:		case 3: //right
src/lib/16_head.c:		default: //null
src/lib/16_head.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_head.h:#include <conio.h> // just for wait
src/lib/16_head.h:#include <time.h> // just for wait
src/lib/16_head.h:#include <stdint.h> //16_vrs.h
src/lib/16_head.h://here temperarly
src/lib/16_head.h:#define KEY_DASH		(0x0C)	// -_
src/lib/16_head.h:#define KEY_EQUAL		(0x0D)	// =+
src/lib/16_head.h:#define KEY_LBRACKET	(0x1A)	// [{
src/lib/16_head.h:#define KEY_RBRACKET	(0x1B)	// ]}
src/lib/16_head.h:#define KEY_SEMICOLON	(0x27)	// ;:
src/lib/16_head.h:#define KEY_RQUOTE	(0x28)	// '"
src/lib/16_head.h:#define KEY_LQUOTE	(0x29)	// `~
src/lib/16_head.h:#define KEY_PERIOD	(0x33)	// .>
src/lib/16_head.h:#define KEY_COMMA		(0x34)	// ,<
src/lib/16_head.h:#define KEY_SLASH		(0x35)	// /?
src/lib/16_head.h:#define KEY_BACKSLASH	(0x2B)	// \|
src/lib/16_head.h://static word far* clockw= (word far*) 0x046C; /* 18.2hz clock */
src/lib/16_head.h:extern	int			profilehandle,debughandle;	//make it into game global
src/lib/16_head.h://#define OLD16_VL
src/lib/16_in.c://
src/lib/16_in.c://	ID Engine
src/lib/16_in.c://	ID_IN.c - Input Manager
src/lib/16_in.c://	v1.0d1w
src/lib/16_in.c://	By Jason Blochowiak
src/lib/16_in.c://	Open Watcom port by sparky4
src/lib/16_in.c://
src/lib/16_in.c://
src/lib/16_in.c://	This module handles dealing with the various input devices
src/lib/16_in.c://
src/lib/16_in.c://	Depends on: Memory Mgr (for demo recording), Sound Mgr (for timing stuff),
src/lib/16_in.c://				User Mgr (for command line parms)
src/lib/16_in.c://
src/lib/16_in.c://	Globals:
src/lib/16_in.c://		LastScan - The keyboard scan code of the last key pressed
src/lib/16_in.c://		LastASCII - The ASCII value of the last key pressed
src/lib/16_in.c://	DEBUG - there are more globals
src/lib/16_in.c://
src/lib/16_in.c://extern inconfig inpu;
src/lib/16_in.c://inpu.KbdDefs = {0x1d,0x38,/*0x47,*/0x48,/*0x49,*/0x4b,0x4d,/*0x4f,*/0x50/*,0x51*/};
src/lib/16_in.c:static	byte        far ASCIINames[] =		// Unshifted ASCII for scan codes
src/lib/16_in.c://	 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
src/lib/16_in.c:	0  ,27 ,'1','2','3','4','5','6','7','8','9','0','-','=',8  ,9  ,	// 0
src/lib/16_in.c:	'q','w','e','r','t','y','u','i','o','p','[',']',13 ,0  ,'a','s',	// 1
src/lib/16_in.c:	'd','f','g','h','j','k','l',';',39 ,'`',0  ,92 ,'z','x','c','v',	// 2
src/lib/16_in.c:	'b','n','m',',','.','/',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,	// 3
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',	// 4
src/lib/16_in.c:	'2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 5
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 6
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0		// 7
src/lib/16_in.c:					far ShiftNames[] =		// Shifted ASCII for scan codes
src/lib/16_in.c://	 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
src/lib/16_in.c:	0  ,27 ,'!','@','#','$','%','^','&','*','(',')','_','+',8  ,9  ,	// 0
src/lib/16_in.c:	'Q','W','E','R','T','Y','U','I','O','P','{','}',13 ,0  ,'A','S',	// 1
src/lib/16_in.c:	'D','F','G','H','J','K','L',':',34 ,'~',0  ,'|','Z','X','C','V',	// 2
src/lib/16_in.c:	'B','N','M','<','>','?',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,	// 3
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',	// 4
src/lib/16_in.c:	'2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 5
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 6
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0   	// 7
src/lib/16_in.c:					far SpecialNames[] =	// ASCII for 0xe0 prefixed codes
src/lib/16_in.c://	 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 0
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,13 ,0  ,0  ,0  ,	// 1
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 2
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,'/',0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 3
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 4
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 5
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,	// 6
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0   	// 7
src/lib/16_in.c:					*ScanNames[] =		// Scan code names with single chars
src/lib/16_in.c:					},	// DEBUG - consolidate these
src/lib/16_in.c:					far ExtScanCodes[] =	// Scan codes with >1 char names
src/lib/16_in.c:					*ExtScanNames[] =	// Names corresponding to ExtScanCodes
src/lib/16_in.c:static	Direction	DirTable[] =		// Quick lookup for total direction
src/lib/16_in.c:						//dir_Nortinest,
src/lib/16_in.c:						//dir_NorthEast,
src/lib/16_in.c:						//dir_Soutinest,
src/lib/16_in.c:						//,dir_SouthEast
src/lib/16_in.c://	Internal routines
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_KeyService() - Handles a keyboard interrupt (key up/down)
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	k = inp(0x60);	// Get the scan code
src/lib/16_in.c:	// Tell the XT keyboard controller to clear the key
src/lib/16_in.c:	if (k == 0xe0)		// Special key prefix
src/lib/16_in.c:	else if (k == 0xe1)	// Handle Pause key
src/lib/16_in.c:		if (k & 0x80)	// Break code
src/lib/16_in.c:// DEBUG - handle special keys: ctl-alt-delete, print scrn
src/lib/16_in.c:		else			// Make code
src/lib/16_in.c:					// DEBUG - make caps lock light work
src/lib/16_in.c:				if (inpu.Keyboard[sc_LShift] || inpu.Keyboard[sc_RShift])	// If shifted
src/lib/16_in.c:	//union REGS CPURegs;
src/lib/16_in.c:	//x = CPURegs.x.ax;
src/lib/16_in.c:	//int86(MouseInt,&CPURegs,&CPURegs);
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_GetMouseDelta() - Gets the amount that the mouse has moved from the
src/lib/16_in.c://		mouse driver
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_GetMouseButtons() - Gets the status of the mouse buttons from the
src/lib/16_in.c://		mouse driver
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_GetJoyAbs() - Reads the absolute position of the specified joystick
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	xs = joy? 2 : 0;		// Find shift value for x axis
src/lib/16_in.c:	xb = 1 << xs;			// Use shift value to get x bit mask
src/lib/16_in.c:	ys = joy? 3 : 1;		// Do the same for y axis
src/lib/16_in.c:// Read the absolute joystick values
src/lib/16_in.c:		pushf				// Save some registers
src/lib/16_in.c:		cli					// Make sure an interrupt doesn't screw the timings
src/lib/16_in.c:		out		dx,al		// Clear the resistors
src/lib/16_in.c:		mov		ah,[xb]		// Get masks into registers
src/lib/16_in.c:		xor		si,si		// Clear count registers
src/lib/16_in.c:		xor		bh,bh		// Clear high byte of bx for later
src/lib/16_in.c:		push	bp			// Don't mess up stack frame
src/lib/16_in.c:		in		al,dx		// Get bits indicating whether all are finished
src/lib/16_in.c:		dec		bp			// Check bounding register
src/lib/16_in.c:		jz		done		// We have a silly value - abort
src/lib/16_in.c:		mov		bl,al		// Duplicate the bits
src/lib/16_in.c:		and		bl,ah		// Mask off useless bits (in [xb])
src/lib/16_in.c:		add		si,bx		// Possibly increment count register
src/lib/16_in.c:		mov		cl,bl		// Save for testing later
src/lib/16_in.c:		and		bl,ch		// [yb]
src/lib/16_in.c:		jnz		loo		// If both bits were 0, drop out
src/lib/16_in.c:		mov		cl,[xs]		// Get the number of bits to shift
src/lib/16_in.c:		shr		si,cl		//  and shift the count that many times
src/lib/16_in.c:		mov		[x],si		// Store the values into the variables
src/lib/16_in.c:		popf				// Restore the registers
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_GetJoyDelta() - Returns the relative movement of the specified
src/lib/16_in.c://		joystick (from +/-127, scaled adaptively)
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_GetJoyButtons() - Returns the button status of the specified
src/lib/16_in.c://		joystick
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	result = inp(0x201);	// Get all the joystick buttons
src/lib/16_in.c:	result >>= joy? 6 : 4;	// Shift into bits 0-1
src/lib/16_in.c:	result &= 3;				// Mask off the useless bits
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_GetJoyButtonsDB() - Returns the de-bounced button status of the
src/lib/16_in.c://		specified joystick
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_StartKbd() - Sets up my keyboard stuff for use
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	INL_KeyHook = 0;	// Clear key hook
src/lib/16_in.c:	//_dos_setvect(KeyInt,INL_KeyService);
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_ShutKbd() - Restores keyboard control to the BIOS
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	pokeb(0x40,0x17,peekb(0x40,0x17) & 0xfaf0);	// Clear ctrl/alt/shift flags
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_StartMouse() - Detects and sets up the mouse
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_ShutMouse() - Cleans up after the mouse
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_SetJoyScale() - Sets up scaling values for the specified joystick
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_SetupJoy() - Sets up thresholding values and calls INL_SetJoyScale()
src/lib/16_in.c://		to set up scaling values
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_StartJoy() - Detects & auto-configures the specified joystick
src/lib/16_in.c://					The auto-config assumes the joystick is centered
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_ShutJoy() - Cleans up the joystick stuff
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://	Public routines
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_Startup() - Starts up the Input Mgr
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_Default() - Sets up default conditions for the Input Mgr
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	//int i;
src/lib/16_in.c:	//in.KbdDefs[0].upleft = 0x47;
src/lib/16_in.c:	//in.KbdDefs[0].upright = 0x49;
src/lib/16_in.c:	//in.KbdDefs[0].downleft = 0x4f;
src/lib/16_in.c:	//in.KbdDefs[0].downright = 0x51;
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_Shutdown() - Shuts down the Input Mgr
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_SetKeyHook() - Sets the routine that gets called by INL_KeyService()
src/lib/16_in.c://			everytime a real make/break code gets hit
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_ClearKeyDown() - Clears the keyboard array
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	//int	i;
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	INL_AdjustCursor() - Internal routine of common code from IN_ReadCursor()
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_ReadCursor() - Reads the input devices and fills in the cursor info
src/lib/16_in.c://		struct
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_ReadControl() - Reads the device associated with the specified
src/lib/16_in.c://		player and fills in the control info struct
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://TODO: make this into a function that the joystick AND keyboard can use wwww
src/lib/16_in.c:			if(DIRECTIONIFELSE)//(player->info.dir == 2)
src/lib/16_in.c:			}else{	//2 keys pressed
src/lib/16_in.c:							if((inpu.Keyboard[def->left] && !inpu.Keyboard[def->right])){ dir = DirTable[1]; }//mx = motion_Left; }
src/lib/16_in.c:							else if((inpu.Keyboard[def->right] && !inpu.Keyboard[def->left])){ dir = DirTable[3]; }//mx = motion_Right; }
src/lib/16_in.c:							if((inpu.Keyboard[def->up] && !inpu.Keyboard[def->down])){ dir = DirTable[0]; }//my = motion_Up; }
src/lib/16_in.c:							else if((inpu.Keyboard[def->down] && !inpu.Keyboard[def->up])){ dir = DirTable[4]; }//my = motion_Down; }
src/lib/16_in.c:					//if(dbg_testcontrolnoisy > 0){ printf("dir=%c ", dirchar(dir)); printf("pdir=%c	", dirchar(player->pdir)); }
src/lib/16_in.c:			//input from player
src/lib/16_in.c:		dx = mx;// * 127;
src/lib/16_in.c:		dy = my;// * 127;
src/lib/16_in.c://	player->info.dir = DirTable[((my + 1) * 3) + (mx + 1)];
src/lib/16_in.c:		// Pack the control info into a byte
src/lib/16_in.c:	//printf("b1=%u b2=%u b3=%u b4=%u	", player->info.button0, player->info.button1, player->info.button2, player->info.button3);
src/lib/16_in.c:	//printf("q=%d ", player->q);
src/lib/16_in.c:	//printf("cpee=%c ", dirchar(conpee));
src/lib/16_in.c:	//else if(!realdelta) printf("%c%d %c%d %c%d %c%d", dirchar(0), inpu.Keyboard[def->up], dirchar(4), inpu.Keyboard[def->down], dirchar(1), inpu.Keyboard[def->left], dirchar(3), inpu.Keyboard[def->right]);
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_SetControlType() - Sets the control type to be used by the specified
src/lib/16_in.c://		player
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:	// DEBUG - check that requested type is present?
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_StartDemoRecord() - Starts the demo recording, using a buffer the
src/lib/16_in.c://		size passed. Returns if the buffer allocation was successful
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_StartDemoPlayback() - Plays back the demo pointed to of the given size
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_StopDemo() - Turns off demo mode
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_FreeDemoBuffer() - Frees the demo buffer, if it's been allocated
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_GetScanName() - Returns a string containing the name of the
src/lib/16_in.c://		specified scan code
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_WaitForKey() - Waits for a scan code, then clears LastScan and
src/lib/16_in.c://		returns the scan code
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_WaitForASCII() - Waits for an ASCII char, then clears LastASCII and
src/lib/16_in.c://		returns the ASCII value
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_AckBack() - Waits for either an ASCII keypress or a button press
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_Ack() - Clears user input & then calls IN_AckBack()
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_IsUserInput() - Returns true if a key has been pressed or a button
src/lib/16_in.c://		is down
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://
src/lib/16_in.c://	IN_UserInput() - Waits for the specified delay time (in ticks) or the
src/lib/16_in.c://		user pressing a key or a mouse button. If the clear flag is set, it
src/lib/16_in.c://		then either clears the key or waits for the user to let the mouse
src/lib/16_in.c://		button up.
src/lib/16_in.c://
src/lib/16_in.c:///////////////////////////////////////////////////////////////////////////
src/lib/16_in.c://	if(dbg_testkeyin > 0) printf("%u\n", inpu.Keyboard[kee]);
src/lib/16_in.c://init player!
src/lib/16_in.c:	player->spt=(TILEWH/(player->speed));	//speed per tile wwww
src/lib/16_in.h://
src/lib/16_in.h://	ID Engine
src/lib/16_in.h://	ID_IN.h - Header file for Input Manager
src/lib/16_in.h://	v1.0d1w
src/lib/16_in.h://	By Jason Blochowiak
src/lib/16_in.h://	Open Watcom port by sparky4
src/lib/16_in.h://
src/lib/16_in.h:#ifdef __WATCOMC__	//borland C BCEXMM.EXE
src/lib/16_in.h://#include "src/lib/bitmap.h"	//old format
src/lib/16_in.h://if else for gfxtesting and direction
src/lib/16_in.h://player[pn].d == 2 ||
src/lib/16_in.h://player[pn].d != 2 ||
src/lib/16_in.h:#define DIRECTIONIFELSE	(player->info.dir == 2)//(player[pn].info.dir == 2)
src/lib/16_in.h://#define NDIRECTIONIFELSE	(player->info.dir != 2)//(player[pn].info.dir != 2)
src/lib/16_in.h:#define	KeyInt	9	// The keyboard ISR number
src/lib/16_in.h:// Stuff for the joystick
src/lib/16_in.h:// 	Stuff for the mouse
src/lib/16_in.h:						//ctrl_None,				// MDM (GAMERS EDGE) - added
src/lib/16_in.h:						dir_North,//dir_NorthEast,
src/lib/16_in.h:						dir_West,//dir_Nortinest,
src/lib/16_in.h:						dir_East,//,dir_SouthEast,
src/lib/16_in.h:						dir_South,//dir_Soutinest,
src/lib/16_in.h:									//upleft,
src/lib/16_in.h:									//upright,
src/lib/16_in.h:									//downleft,
src/lib/16_in.h:									//,downright
src/lib/16_in.h:	int x; //player exact position on the viewable map
src/lib/16_in.h:	int y; //player exact position on the viewable map
src/lib/16_in.h:	int tx; //player tile position on the viewable map
src/lib/16_in.h:	int ty; //player tile position on the viewable map
src/lib/16_in.h:	int triggerx; //player's trigger box tile position on the viewable map
src/lib/16_in.h:	int triggery; //player's trigger box tile position on the viewable map
src/lib/16_in.h:	int sheetsetx; //NOT USED YET! player sprite sheet set on the image x
src/lib/16_in.h:	int sheetsety; //NOT USED YET! player sprite sheet set on the image y
src/lib/16_in.h:	byte d;		//direction to render sprite!! wwww
src/lib/16_in.h:	byte q;		//loop variable for anumation and locking the playing to compleate the animation cycle to prevent issues with misalignment www
src/lib/16_in.h:	byte near pdir;	//previous direction~
src/lib/16_in.h:	//byte near kd[2];	//array of arrow key pressed
src/lib/16_in.h:	word speed;		//player speed!
src/lib/16_in.h:	word spt;		//speed per tile
src/lib/16_in.h://0000	planar_buf_t huge *data; //supposively the sprite sheet data
src/lib/16_in.h://	planar_buf_t data; //supposively the sprite sheet data
src/lib/16_in.h:////0000----
src/lib/16_in.h:	struct sprite	*spri;	//supposively the sprite sheet data
src/lib/16_in.h:	bitmap_t *data;		//supposively the sprite sheet data//old format
src/lib/16_in.h:	sword hp; //hitpoints of the player
src/lib/16_in.h://	Internal routines
src/lib/16_in.h://static void INL_GetMouseDelta(int *x,int *y);
src/lib/16_in.h://static word INL_GetMouseButtons(void);
src/lib/16_in.h://static void INL_GetJoyDelta(word joy,int *dx,int *dy,boolean adaptive);
src/lib/16_in.h://static word INL_GetJoyButtons(word joy);
src/lib/16_in.h://static void INL_StartKbd(void);
src/lib/16_in.h://static void INL_ShutKbd(void);
src/lib/16_in.h://static boolean INL_StartMouse(void);
src/lib/16_in.h://static void INL_ShutMouse(void);
src/lib/16_in.h://static void INL_SetJoyScale(word joy);
src/lib/16_in.h://static boolean INL_StartJoy(word joy);
src/lib/16_in.h://static void INL_ShutJoy(word joy);
src/lib/16_in.h://static void INL_AdjustCursor(CursorInfo *info,word buttons,int dx,int dy);
src/lib/16_map.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_map.c:// Ideally, preprocess json during compilation and read serialized data
src/lib/16_map.c:	//char *s;
src/lib/16_map.c:					//fix this to be far~
src/lib/16_map.c:					//Fix to load tileset specified.
src/lib/16_map.c:					//And move to vrs, probably
src/lib/16_map.c:					//bp = bitmapLoadPcx("data/ed.pcx");
src/lib/16_map.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_map.h://#include "stdio.h" included in 16_head.h
src/lib/16_map.h://#include "stdlib.h" included in 16_head.h
src/lib/16_map.h://TODO: 16_mm and 16_ca must handle this
src/lib/16_map.h:	bitmap_t huge *btdata;		//old
src/lib/16_map.h:	planar_buf_t huge *data;	//old
src/lib/16_map.h:	boolean debug_text;	//show the value of the tile! wwww
src/lib/16_map.h://TODO: 16_mm and 16_ca must handle this
src/lib/16_map.h://TODO: add variables from 16_ca
src/lib/16_map.h:	//long		planestart[3];
src/lib/16_map.h:	//unsigned	planelength[3];
src/lib/16_map.h:	byte	* huge *data;	//TODO: 16_mm and 16_ca must handle this
src/lib/16_map.h:	tiles_t **tiles;		//TODO: 16_mm and 16_ca must handle this
src/lib/16_map.h:	unsigned int width, height;		//this has to be positive
src/lib/16_mm.c:// NEWMM.C
src/lib/16_mm.c:void		(* XMSaddr) (void);		// far pointer to XMS driver
src/lib/16_mm.c:	static char	emmname[] = "EMMXXXX0";	//fix by andrius4669
src/lib/16_mm.c:		mov	dx,OFFSET emmname	//fix by andrius4669
src/lib/16_mm.c:		int	0x21		// try to open EMMXXXX0 device
src/lib/16_mm.c:		int	0x21		// get device info
src/lib/16_mm.c:		int	0x21		// get status
src/lib/16_mm.c:		int	0x21		// close handle
src/lib/16_mm.c:		//
src/lib/16_mm.c:		// EMS is good
src/lib/16_mm.c:		//
src/lib/16_mm.c:		//
src/lib/16_mm.c:		// EMS is bad
src/lib/16_mm.c:		//
src/lib/16_mm.c:	//byte	EMS_status;
src/lib/16_mm.c:		int	EMS_INT						// make sure EMS hardware is present
src/lib/16_mm.c:		//mov	[EMS_status],ah
src/lib/16_mm.c:		mov	[EMSVer],ax				//	set EMSVer
src/lib/16_mm.c:		cmp	al,0x32						// only work on ems 3.2 or greater
src/lib/16_mm.c:		int	EMS_INT						// find the page frame address
src/lib/16_mm.c:		int	EMS_INT						// find out how much EMS is there
src/lib/16_mm.c:		jz	noEMS						// no EMS at all to allocate
src/lib/16_mm.c:											//EXPAND DONG!!!!
src/lib/16_mm.c:		jle	getpages					// there is only 1,2,3,or 4 pages
src/lib/16_mm.c:		mov	bx,4						// we can't use more than 4 pages
src/lib/16_mm.c:		mov	ah,EMS_ALLOCPAGES			// allocate up to 64k of EMS
src/lib/16_mm.c:		Quit("MML_ShutdownEMS: Error freeing EMS!\n");	//++++ add something
src/lib/16_mm.c:			mov	bx,[i]			// logical page
src/lib/16_mm.c:			mov	al,bl			// physical page
src/lib/16_mm.c:			mov	dx,[EMSHandle]	// handle
src/lib/16_mm.c://SUB EMS.MapXPages (PhysicalStart, LogicalStart, NumPages, Handle)
src/lib/16_mm.c:	//Maps up to 4 logical EMS pages to physical pages in the page frame, where:
src/lib/16_mm.c:	//PhysicalStart = Physical page first logical page is mapped to
src/lib/16_mm.c:	//LogicalStart  = First logical page to map
src/lib/16_mm.c:	//NumPages      = Number of pages to map (1 to 4)
src/lib/16_mm.c:	//Handle        = EMS handle logical pages are allocated to
src/lib/16_mm.c:  /*//Create a buffer containing the page information
src/lib/16_mm.c://  FOR x = 0 TO NumPages - 1
src/lib/16_mm.c://    MapInfo$ = MapInfo$ + MKI$(LogicalStart + x) + MKI$(PhysicalStart + x)
src/lib/16_mm.c://  NEXT*/
src/lib/16_mm.c://  Regs.ax = 0x5000                           //Map the pages in the buffer
src/lib/16_mm.c://  Regs.cx = NumPages                         //to the pageframe
src/lib/16_mm.c://  Regs.dx = Handle
src/lib/16_mm.c://  Regs.ds = VARSEG(MapInfo$)
src/lib/16_mm.c://  Regs.si = SADD(MapInfo$)
src/lib/16_mm.c://  InterruptX 0x67, Regs, Regs
src/lib/16_mm.c://	EMS.Error = (Regs.ax AND 0xFF00&) \ 0x100  //Store the status code
src/lib/16_mm.c://END SUB
src/lib/16_mm.c:			mov	cx,[i]			// logical page
src/lib/16_mm.c:			mov	al,bl			// physical page
src/lib/16_mm.c:			mov	dx,[EMSHandle]	// handle
src/lib/16_mm.c:			//strcpy(str,"MM_MapXEMS: EMS error 0x");
src/lib/16_mm.c:			//itoa(err,str2,16);
src/lib/16_mm.c:			//printf("%s%x\n",str, err);
src/lib/16_mm.c:			//printf("FACK! %x\n", err);
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//numUMBs = 0;
src/lib/16_mm.c:		int	0x2f				// query status of installed diver
src/lib/16_mm.c:		mov	[WORD PTR XMSaddr+2],es		// function pointer to XMS driver
src/lib/16_mm.c:		mov	dx,0xffff					// try for largest block possible
src/lib/16_mm.c:		//mov     ax,dx						// Set available Kbytes.
src/lib/16_mm.c:		cmp	bl,0xb0						// error: smaller UMB is available
src/lib/16_mm.c:		call	[DWORD PTR XMSaddr]		// DX holds largest available UMB
src/lib/16_mm.c:		jz	done						// another error...
src/lib/16_mm.c://	printf("base=%u	", base); printf("size=%u\n", size);
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *last;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// reset rover to start of memory
src/lib/16_mm.c://
src/lib/16_mm.c:// search for the block that contains the range of segments
src/lib/16_mm.c://
src/lib/16_mm.c://
src/lib/16_mm.c:// take the given range out of the block
src/lib/16_mm.c://
src/lib/16_mm.c:	//++++emsver stuff!
src/lib/16_mm.c:	if(segm>1)/// || extra>=0x10000lu)
src/lib/16_mm.c:	//if(extra>0xfffflu)
src/lib/16_mm.c:		//MML_UseSpace(segstart, seglength, gvar);
src/lib/16_mm.c:	//}
src/lib/16_mm.c://++++todo: linked list of segment!
src/lib/16_mm.c:		last->next = scan->next;			// unlink block
src/lib/16_mm.c:		scan->length = segstart-scan->start;	// shorten block
src/lib/16_mm.c:	}//else if(segm>0) goto segu;
src/lib/16_mm.c:	//word segm=1;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// reset rover to start of memory
src/lib/16_mm.c://
src/lib/16_mm.c:// search for the block that contains the range of segments
src/lib/16_mm.c://
src/lib/16_mm.c://
src/lib/16_mm.c:// find out how many blocks it spans!
src/lib/16_mm.c://
src/lib/16_mm.c:		//printf("	seglen=%lu\n", segmlen);
src/lib/16_mm.c://
src/lib/16_mm.c:// take the given range out of the block
src/lib/16_mm.c://
src/lib/16_mm.c:		//return;
src/lib/16_mm.c:		last->next = scan->next;			// unlink block
src/lib/16_mm.c:		scan->length = segstart-scan->start;	// shorten block
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *last;
src/lib/16_mm.c:	mmblocktype __far *scan;//,far *last;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//dword length,seglength;
src/lib/16_mm.c:	//huge void huge	*start;
src/lib/16_mm.c:	word	segstart;//,endfree;
src/lib/16_mm.c:	//memptr *peeonself;
src/lib/16_mm.c://
src/lib/16_mm.c:// set up the linked list (everything in the free list;
src/lib/16_mm.c://
src/lib/16_mm.c://
src/lib/16_mm.c:// locked block of all memory until we punch out free space
src/lib/16_mm.c://
src/lib/16_mm.c:	gvar->mm.mmhead = gvar->mm.mmnew;				// this will allways be the first node
src/lib/16_mm.c:	//gvar->mm.mmnew->useptr = peeonself;
src/lib/16_mm.c:	//printf("		%x\n", peeonself);
src/lib/16_mm.c:	//printf("		%x\n", *peeonself);
src/lib/16_mm.c://
src/lib/16_mm.c:// get all available near conventional memory segments
src/lib/16_mm.c://
src/lib/16_mm.c:	length=(dword)_memavl();//(dword)GetFreeSize();
src/lib/16_mm.c:	//huge start = (void huge *)(gvar->mm.nearheap = _nmalloc(length));
src/lib/16_mm.c:	//huge start = (void huge *)(gvar->mm.nearheap = malloc(length));
src/lib/16_mm.c:	seglength = length / 16;			// now in paragraphs
src/lib/16_mm.c:	//printf("start=%Fp	segstart=%x	seglen=%lu	len=%lu\n", start, segstart, seglength, length);
src/lib/16_mm.c://
src/lib/16_mm.c:// get all available far conventional memory segments
src/lib/16_mm.c://
src/lib/16_mm.c:	//printf("_FARCORELEFT				%lu\n", _FCORELEFT);
src/lib/16_mm.c:	length=_FCORELEFT;//_fcoreleft();//(dword)GetFarFreeSize();//0xffffUL*4UL;
src/lib/16_mm.c:	length=farcoreleft();//_fcoreleft();//(dword)GetFarFreeSize();//0xffffUL*4UL;
src/lib/16_mm.c:	//start = gvar->mm.farheap = halloc(length, 1);
src/lib/16_mm.c:	seglength = length / 16;			// now in paragraphs
src/lib/16_mm.c:	//printf("start=%Fp	segstart=%x	seglen=%lu	len=%lu\n", start, segstart, seglength, length);
src/lib/16_mm.c://
src/lib/16_mm.c:// detect EMS and allocate up to 64K at page frame
src/lib/16_mm.c://
src/lib/16_mm.c://goto emsskip;	//0000
src/lib/16_mm.c:			goto emsskip;				// param NOEMS
src/lib/16_mm.c:		MML_SetupEMS(gvar);					// allocate space
src/lib/16_mm.c:		//16_PM: EMS4! AND EMS 3.2 MASSIVE DATA HANDLMENT!
src/lib/16_mm.c:		//if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_mm.c:			MM_MapEMS(gvar);					// map in used pages
src/lib/16_mm.c:		//else
src/lib/16_mm.c:			//MM_MapXEMS(gvar);					// map in used pages
src/lib/16_mm.c://
src/lib/16_mm.c:// detect XMS and get upper memory blocks
src/lib/16_mm.c://
src/lib/16_mm.c:goto xmsskip;//0000
src/lib/16_mm.c:			goto xmsskip;				// param NOXMS
src/lib/16_mm.c:		MML_SetupXMS(gvar);					// allocate as many UMBs as possible
src/lib/16_mm.c://
src/lib/16_mm.c:// allocate the misc buffer
src/lib/16_mm.c://
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// start looking for space after low block
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	_ffree(gvar->mm.farheap);//	printf("		far freed\n");
src/lib/16_mm.c:	_nfree(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	free(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	if(MML_CheckForEMS()){ MML_ShutdownEMS(gvar); }//printf("		EMS freed\n"); }
src/lib/16_mm.c:	if(MML_CheckForXMS()){ MML_ShutdownXMS(gvar); }//printf("		XMS freed\n"); }
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *lastscan,huge *endscan,huge *purge,huge *next;
src/lib/16_mm.c:	needed = (size+15)/16;		// convert size from bytes to paragraphs
src/lib/16_mm.c:	GETNEWBLOCK;				// fill in start and next after a spot is found
src/lib/16_mm.c:	//if(gvar->mm.mmnew->useptr==NULL){
src/lib/16_mm.c:		//%04x
src/lib/16_mm.c:	//exit(-5); }
src/lib/16_mm.c://tryagain:
src/lib/16_mm.c:	//
src/lib/16_mm.c:	// first search:	try to allocate right after the rover, then on up
src/lib/16_mm.c:	// second search: 	search from the head pointer up to the rover
src/lib/16_mm.c:	// third search:	compress memory, then scan from start
src/lib/16_mm.c:			//
src/lib/16_mm.c:			// got enough space between the end of lastscan and
src/lib/16_mm.c:			// the start of scan, so throw out anything in the middle
src/lib/16_mm.c:			// and allocate the new block
src/lib/16_mm.c:			//
src/lib/16_mm.c:				{	// free the purgable block
src/lib/16_mm.c:					purge = next;		// purge another if not at scan
src/lib/16_mm.c:				return;	// good allocation!
src/lib/16_mm.c:			//
src/lib/16_mm.c:			// if this block is purge level zero or locked, skip past it
src/lib/16_mm.c:			//
src/lib/16_mm.c:			scan=scan->next;		// look at next line
src/lib/16_mm.c:		//heapdump();
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *last;
src/lib/16_mm.c:	if(baseptr == gvar->mm.mmrover->useptr)	// removed the last allocated block
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *start;
src/lib/16_mm.c:			//return;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *start;
src/lib/16_mm.c:			//return;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *last,huge *next;
src/lib/16_mm.c:	unsigned	start,length,source,dest;//++++,oldborder;
src/lib/16_mm.c:	//++++int			playing;
src/lib/16_mm.c:	//
src/lib/16_mm.c:	// lock down a currently playing sound
src/lib/16_mm.c:	//
src/lib/16_mm.c://	oldborder = bordercolor;
src/lib/16_mm.c://	VW_ColorBorder (15);
src/lib/16_mm.c:	last = NULL;		// shut up compiler warning
src/lib/16_mm.c:		//
src/lib/16_mm.c:		// block is locked, so try to pile later blocks right after it
src/lib/16_mm.c:		//
src/lib/16_mm.c:			//
src/lib/16_mm.c:			// throw out the purgable block
src/lib/16_mm.c:			//
src/lib/16_mm.c:				//MM_FreeBlock(scan, gvar);
src/lib/16_mm.c:			//
src/lib/16_mm.c:			// push the non purgable block on top of the last moved block
src/lib/16_mm.c:			//
src/lib/16_mm.c:		scan = scan->next;		// go to next block
src/lib/16_mm.c://	VW_ColorBorder (oldborder);
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan;
src/lib/16_mm.c:	//word temp;
src/lib/16_mm.c:	//word chx,chy;
src/lib/16_mm.c:	//dword wwww;
src/lib/16_mm.c:	byte    scratch[160],scratch0[4096],str[16];//[[[[scratch1[160],
src/lib/16_mm.c:	//byte d = '#';
src/lib/16_mm.c://[[[[	VW_SetDefaultColors();
src/lib/16_mm.c://[[[[	VW_SetLineWidth(40);
src/lib/16_mm.c://++++mh	temp = bufferofs;
src/lib/16_mm.c://++++mh	bufferofs = 0;
src/lib/16_mm.c://[[[[	VW_SetScreen (0,0);
src/lib/16_mm.c:			strcpy(scratch0, AAMAGENTA);		// dark purple = purgable
src/lib/16_mm.c:			strcpy(scratch0, AABLUE);		// medium blue = non purgable
src/lib/16_mm.c: 			strcpy(scratch0, AARED);		// red = locked
src/lib/16_mm.c:			//modexprint(&page, chx, chy, 1, 0, 24, "\nMM_ShowMemory: Memory block order currupted!\n");
src/lib/16_mm.c://++++		chy = scan->start/320;
src/lib/16_mm.c://++++		chx = scan->start%320;
src/lib/16_mm.c:				//modexhlin(page, scan->start, (unsigned)end, chy, color);
src/lib/16_mm.c:				//for(chx=scan->start;chx+4>=(word)end;chx+=4)
src/lib/16_mm.c:				//{
src/lib/16_mm.c://++++					modexClearRegion(page, chx, chy, 4, 4, color);
src/lib/16_mm.c:				//}
src/lib/16_mm.c://++++		VW_Hlin(scan->start,(unsigned)end,0,color);
src/lib/16_mm.c:			//printf("+	%u	%lu\n", w, scan->length);
src/lib/16_mm.c:		//++==++==optional strcat(scratch0, AARESET); strcat(scratch0, AAGREY); strcat(scratch0,"_");
src/lib/16_mm.c://++++		VW_Plot(scan->start,0,15);
src/lib/16_mm.c://++++				modexClearRegion(page, chx, chy, 4, 4, 15);
src/lib/16_mm.c://++++			VW_Hlin(end+1,scan->next->start,0,0);	// black = free
src/lib/16_mm.c:		//wwww=(dword)(scan->next->start)-(dword)scan->start;
src/lib/16_mm.c:		//wwww=(dword)scan->start+(dword)(scan->next->start);
src/lib/16_mm.c:			//++==++==optional strcat(scratch0, "\n");
src/lib/16_mm.c:			//for(w=(wwww)/80;w<=((end+1)/80);w++)
src/lib/16_mm.c:			//for(w=(end+1)/80;w<=((wwww)/80);w++)
src/lib/16_mm.c:				//printf("0	%x	%u	%lu\n", scan->next->start, w, scan->length);
src/lib/16_mm.c:			//printf("==================\n");
src/lib/16_mm.c:			//printf("w=%u	wwww=%lu	start=%04x	next=%04x	end=%lu\n", w/80, wwww/80, scan->start, (scan->next->start), end+1);
src/lib/16_mm.c:			//printf("==================\n");
src/lib/16_mm.c:			//getch();
src/lib/16_mm.c:		}/*else {//if(scan->next->start <= scan->start){
src/lib/16_mm.c:				//printf("0	%x	%x	%u\n", scan->start, w);
src/lib/16_mm.c:		//strcat(scratch0,"\n");
src/lib/16_mm.c:			//for(chx=scan->next->start;chx+4>=(word)end+1;chx+=4)
src/lib/16_mm.c:			//{
src/lib/16_mm.c://				chx+=scan->next->start;
src/lib/16_mm.c://				modexClearRegion(page, chx, chy, 4, 4, 2);
src/lib/16_mm.c:			//}
src/lib/16_mm.c:					//modexhlin(page, end+1,scan->next->start, chy, 0);
src/lib/16_mm.c://++++			VW_Hlin(x+end+1,x+(scan->next->start-scan->start),y,0);	// black = free
src/lib/16_mm.c://modexprint(page, chx, chy, 1, 0, 24, &scratch);
src/lib/16_mm.c://++++chy+=4;
src/lib/16_mm.c://fprintf(stdout, "%s", scratch);
src/lib/16_mm.c:	//strcat(scratch1, "&near=	%Fp ", &(gvar->mm.nearheap));
src/lib/16_mm.c:	//strcat(scratch1, "&far=	%Fp", &(gvar->mm.farheap));
src/lib/16_mm.c:	//strcat(scratch1, "\n");
src/lib/16_mm.c://++++mh	IN_Ack();
src/lib/16_mm.c://****	VW_SetLineWidth(64);
src/lib/16_mm.c://++++mh	bufferofs = temp;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan,huge *best;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan;
src/lib/16_mm.c://	return free;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//huge mmblocktype huge *scan;
src/lib/16_mm.c://	return free;
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//printf("mainmem:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	//printf("Total convmem:	%lu	", gvar->mmi.mainmem); printf("TotalFree:	%lu	", MM_TotalFree(gvar)+gvar->mmi.EMSmem+gvar->mmi.XMSmem+gvar->mmi.XMSmem); printf("TotalUsed:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	//printf("			UnusedMemory:	%lu\n", MM_UnusedMemory(gvar));
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.c:	//Returns a text string describing the error code in EMS.Error.
src/lib/16_mm.c://==========================================================================
src/lib/16_mm.h:// ID_MM.H
src/lib/16_mm.h://++++mh	#include "src/lib/16_in.h"
src/lib/16_mm.h:#ifdef __DEBUG__		// 1 == Debug/Dev  ;  0 == Production/final
src/lib/16_mm.h://#define GETNEWBLOCK {if(!(mmnew=mmfree))Quit("MM_GETNEWBLOCK: No free blocks!") ;mmfree=mmfree->next;}
src/lib/16_mm.h:#define SAVENEARHEAP	0x200		// space to leave in data segment
src/lib/16_mm.h:#define SAVEFARHEAP	0//x400			// space to leave in far heap
src/lib/16_mm.h:#define	BUFFERSIZE		0x1000		// miscelanious, allways available buffer
src/lib/16_mm.h://moved to typdefst
src/lib/16_mm.h://#define MAXBLOCKS		1024
src/lib/16_mm.h://--------
src/lib/16_mm.h://--------
src/lib/16_mm.h:/*__asm { mov ah,[v]\*///}
src/lib/16_mm.h://==========================================================================
src/lib/16_mm.h://moved to typdefst
src/lib/16_mm.h://==========================================================================
src/lib/16_mm.h:extern	void		(* XMSaddr) (void);		// far pointer to XMS driver
src/lib/16_mm.h://==========================================================================
src/lib/16_mm.h:#define LOCKBIT		0x80	// if set in attributes, block cannot be moved
src/lib/16_mm.h:#define PURGEBITS	3		// 0-3 level, 0= unpurgable, 3= purge first
src/lib/16_mm.h:#define BASEATTRIBUTES	0	// unlocked, non purgable
src/lib/16_mm.h://moved to typedefst
src/lib/16_mm.h://#define MAXUMBS		12
src/lib/16_mm.h:#define MAPPAGES		4//gvar->mm.EMSpagesmapped
src/lib/16_mm.h://moved to typdefst
src/lib/16_mm.h:	//word	start;	dword length;
src/lib/16_mm.h:	word	blob;	//for data larger than 64k
src/lib/16_mm.h:	memptr		*useptr;	// pointer to the segment start
src/lib/16_mm.h:	//huge struct mmblockstruct huge *next;
src/lib/16_mm.h:	//huge void huge	*farheap;
src/lib/16_mm.h:	//byte		EMS_status;
src/lib/16_mm.h:	//dword	numUMBs,UMBbase[MAXUMBS];
src/lib/16_mm.h:	//huge mmblocktype	huge mmblocks[MAXBLOCKS],huge *mmhead,huge *mmfree,huge *mmrover,huge *mmnew;
src/lib/16_mm.h://==========================================================================
src/lib/16_mm.h://byte MML_SetupEMS(mminfo_t *mm);
src/lib/16_mm.h://void MML_ShutdownEMS(mminfo_t *mm);
src/lib/16_mm.h://byte MM_MapXEMS(global_game_variables_t *gvar);
src/lib/16_mm.h://void MML_SetupXMS(mminfo_t *mm, mminfotype *mmi);
src/lib/16_mm.h://void MML_ShutdownXMS(mminfo_t *mm);
src/lib/16_mm.h://void MM_GetNewBlock(mminfo_t *mm);
src/lib/16_mm.h://void MM_FreeBlock(mmblocktype *x, mminfo_t *mm);
src/lib/16_mm.h://==========================================================================
src/lib/16_pm.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_pm.c://
src/lib/16_pm.c://	ID_PM.C
src/lib/16_pm.c://	Id Engine's Page Manager v1.0
src/lib/16_pm.c://	Primary coder: Jason Blochowiak
src/lib/16_pm.c://
src/lib/16_pm.c://	Main Mem specific variables
src/lib/16_pm.c:	//boolean			MainPresent;
src/lib/16_pm.c://	EMS specific variables
src/lib/16_pm.c:	//boolean			EMSPresent;
src/lib/16_pm.c://	XMS specific variables
src/lib/16_pm.c:	//boolean			XMSPresent;
src/lib/16_pm.c:	//word			gvar->pm.xmm.XMSAvail,gvar->pm.xmm.XMSPagesAvail,gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:	dword			XMSDriver;	//hard to put in gvar
src/lib/16_pm.c:	word				XMSVer;	//hard to put in gvar
src/lib/16_pm.c://	File specific variables
src/lib/16_pm.c://	General usage variables
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	EMS Management code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_MapEMS() - Maps a logical page to a physical page
src/lib/16_pm.c://
src/lib/16_pm.c:	//int	i;
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_StartupEMS() - Sets up EMS for Page Mgr's use
src/lib/16_pm.c://		Checks to see if EMS driver is present
src/lib/16_pm.c://      Verifies that EMS hardware is present
src/lib/16_pm.c://		Make sure that EMS version is 3.2 or later
src/lib/16_pm.c://		If there's more than our minimum (2 pages) available, allocate it (up
src/lib/16_pm.c://			to the maximum we need)
src/lib/16_pm.c://
src/lib/16_pm.c:	//long	size;
src/lib/16_pm.c:	static char	emmname[] = "EMMXXXX0";	//fix by andrius4669
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = false;			// Assume that we'll fail
src/lib/16_pm.c:		mov	dx,OFFSET emmname	//fix by andrius4669
src/lib/16_pm.c:		int	EMM_INT		// try to open EMMXXXX0 device
src/lib/16_pm.c:		int	EMM_INT		// get device info
src/lib/16_pm.c:		int	EMM_INT		// get status
src/lib/16_pm.c:		int	EMM_INT		// close handle
src/lib/16_pm.c:		jc	error1			// make sure EMS hardware is present
src/lib/16_pm.c:		int	EMS_INT			// only work on EMS 3.2 or greater (silly, but...)
src/lib/16_pm.c:		mov	[EMSVer],ax		//	set EMSVer
src/lib/16_pm.c:		cmp	al,0x32			// only work on ems 3.2 or greater
src/lib/16_pm.c:		int	EMS_INT			// find the page frame address
src/lib/16_pm.c:		int	EMS_INT			// find out how much EMS is there
src/lib/16_pm.c:		jz	noEMS			// no EMS at all to allocate
src/lib/16_pm.c:		jl	noEMS			// Require at least 2 pages (32k)
src/lib/16_pm.c:		// Don't hog all available EMS
src/lib/16_pm.c:	// Initialize EMS mapping cache
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = true;			// We have EMS
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_ShutdownEMS() - If EMS was used, deallocate it
src/lib/16_pm.c://
src/lib/16_pm.c:			//return;
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	XMS Management code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_StartupXMS() - Starts up XMS for the Page Mgr's use
src/lib/16_pm.c://		Checks for presence of an XMS driver
src/lib/16_pm.c://		Makes sure that there's at least a page of XMS available
src/lib/16_pm.c://		Allocates any remaining XMS (rounded down to the nearest page size)
src/lib/16_pm.c://
src/lib/16_pm.c://TODO: translate the _REG into working assembly
src/lib/16_pm.c://#define STARTUPXMSASM
src/lib/16_pm.c:	word XMSAvail, XMSHandle;//, XMSVer;
src/lib/16_pm.c:	gvar->pm.xmm.XMSPresent = false;					// Assume failure
src/lib/16_pm.c:		int	XMS_INT         				// Check for presence of XMS driver
src/lib/16_pm.c:		int	XMS_INT							// Get address of XMS driver
src/lib/16_pm.c:		mov	[WORD PTR XMSDriver+2],es		// function pointer to XMS driver
src/lib/16_pm.c:		call	[DWORD PTR XMSDriver]						//; Get XMS Version Number
src/lib/16_pm.c:		mov	ah,XMS_QUERYFREE			// Find out how much XMS is available
src/lib/16_pm.c:		or	ax,ax				// AJR: bugfix 10/8/92
src/lib/16_pm.c:	XMS_CALL(XMS_QUERYFREE);			// Find out how much XMS is available
src/lib/16_pm.c:	if (!_AX)				// AJR: bugfix 10/8/92
src/lib/16_pm.c:	XMSAvail &= ~(PMPageSizeKB - 1);	// Round off to nearest page size
src/lib/16_pm.c:	if (XMSAvail < (PMPageSizeKB * 2))	// Need at least 2 pages
src/lib/16_pm.c:		mov	ah,XMS_ALLOC				// And do the allocation
src/lib/16_pm.c:		or	ax,ax				// AJR: bugfix 10/8/92
src/lib/16_pm.c:	XMS_CALL(XMS_ALLOC);				// And do the allocation
src/lib/16_pm.c:	if (!_AX)				// AJR: bugfix 10/8/92
src/lib/16_pm.c:		//gvar->pm.xmm.XMSVer = XMSVer;
src/lib/16_pm.c:		//printf("XMSHandle\n");
src/lib/16_pm.c:		//printf("	1=%u	2=%u	3=%u	4=%u\n", XMSHandle1, XMSHandle2, XMSHandle3, XMSHandle4);
src/lib/16_pm.c:		//printf("	2=%u	", XMSHandle);
src/lib/16_pm.c:		//printf("	%u", gvar->pm.xmm.XMSHandle);
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_XMSCopy() - Copies a main/EMS page to or from XMS
src/lib/16_pm.c://		Will round an odd-length request up to the next even value
src/lib/16_pm.c://
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_CopyToXMS() - Copies the specified number of bytes from the real mode
src/lib/16_pm.c://		segment address to the specified XMS page
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_CopyFromXMS() - Copies the specified number of bytes from an XMS
src/lib/16_pm.c://		page to the specified real mode address
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_ShutdownXMS()
src/lib/16_pm.c://
src/lib/16_pm.c:			//XMS_CALL(XMS_FREE);
src/lib/16_pm.c:			//mov	err,ah
src/lib/16_pm.c:			//return;
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	Main memory code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_SetMainMemPurge() - Sets the purge level for all allocated main memory
src/lib/16_pm.c://		blocks. This shouldn't be called directly - the PM_LockMainMem() and
src/lib/16_pm.c://		PM_UnlockMainMem() macros should be used instead.
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_CheckMainMem() - If something besides the Page Mgr makes requests of
src/lib/16_pm.c://		the Memory Mgr, some of the Page Mgr's blocks may have been purged,
src/lib/16_pm.c://		so this function runs through the block list and checks to see if
src/lib/16_pm.c://		any of the blocks have been purged. If so, it marks the corresponding
src/lib/16_pm.c://		page as purged & unlocked, then goes through the block list and
src/lib/16_pm.c://		tries to reallocate any blocks that have been purged.
src/lib/16_pm.c://	This routine now calls PM_LockMainMem() to make sure that any allocation
src/lib/16_pm.c://		attempts made during the block reallocation sweep don't purge any
src/lib/16_pm.c://		of the other blocks. Because PM_LockMainMem() is called,
src/lib/16_pm.c://		PM_UnlockMainMem() needs to be called before any other part of the
src/lib/16_pm.c://		program makes allocation requests of the Memory Mgr.
src/lib/16_pm.c://
src/lib/16_pm.c:		if (n != -1)						// Is the page using main memory?
src/lib/16_pm.c:			if (!gvar->pm.mm.MainMemPages[n])			// Yep, was the block purged?
src/lib/16_pm.c:				page->mainPage = -1;		// Yes, mark page as purged & unlocked
src/lib/16_pm.c:	// Prevent allocation attempts from purging any of our other blocks
src/lib/16_pm.c:		if (!*p)							// If the page got purged
src/lib/16_pm.c:			if (*used & pmba_Allocated)		// If it was allocated
src/lib/16_pm.c:				*used &= ~pmba_Allocated;	// Mark as unallocated
src/lib/16_pm.c:				gvar->pm.mm.MainPagesAvail--;			// and decrease available count
src/lib/16_pm.c:			if (*used & pmba_Used)			// If it was used
src/lib/16_pm.c:				*used &= ~pmba_Used;		// Mark as unused
src/lib/16_pm.c:				gvar->pm.MainPagesUsed--;			// and decrease used count
src/lib/16_pm.c:				MM_GetPtr(p,PMPageSize, gvar);		// Try to reallocate
src/lib/16_pm.c:				if (gvar->mm.mmerror)					// If it failed,
src/lib/16_pm.c:					allocfailed = true;			//  don't try any more allocations
src/lib/16_pm.c:				else							// If it worked,
src/lib/16_pm.c:					*used |= pmba_Allocated;	// Mark as allocated
src/lib/16_pm.c:					gvar->pm.mm.MainPagesAvail++;			// and increase available count
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_StartupMainMem() - Allocates as much main memory as is possible for
src/lib/16_pm.c://		the Page Mgr. The memory is allocated as non-purgeable, so if it's
src/lib/16_pm.c://		necessary to make requests of the Memory Mgr, PM_UnlockMainMem()
src/lib/16_pm.c://		needs to be called.
src/lib/16_pm.c://
src/lib/16_pm.c:	int		i;//,n;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_ShutdownMainMem() - Frees all of the main memory blocks used by the
src/lib/16_pm.c://		Page Mgr.
src/lib/16_pm.c://
src/lib/16_pm.c:	// DEBUG - mark pages as unallocated & decrease page count as appropriate
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	File management code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_ReadFromFile() - Reads some data in from the page file
src/lib/16_pm.c://
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_OpenPageFile() - Opens the page file and sets up the page info
src/lib/16_pm.c://
src/lib/16_pm.c:				//__SEGA buf;
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:	// Read in header variables
src/lib/16_pm.c:	// Allocate and clear the page list
src/lib/16_pm.c:	// Read in the chunk offsets
src/lib/16_pm.c:		//return;
src/lib/16_pm.c:	// Read in the chunk lengths
src/lib/16_pm.c:		//return;
src/lib/16_pm.c://
src/lib/16_pm.c://  PML_ClosePageFile() - Closes the page file
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	Allocation, etc., code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_GetEMSAddress()
src/lib/16_pm.c://
src/lib/16_pm.c:// 		Page is in EMS, so figure out which EMS physical page should be used
src/lib/16_pm.c://  		to map our page in. If normal page, use EMS physical page 3, else
src/lib/16_pm.c://  		use the physical page specified by the lock type
src/lib/16_pm.c://
src/lib/16_pm.c:#pragma argsused	// DEBUG - remove lock parameter
src/lib/16_pm.c:	// See if this page is already mapped in
src/lib/16_pm.c:			emspage = i;	// Yep - don't do a redundant remapping
src/lib/16_pm.c:	// If page isn't already mapped in, find LRU EMS frame, and use it
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_GetPageAddress() - Returns the address of a given page
src/lib/16_pm.c://		Maps in EMS if necessary
src/lib/16_pm.c://		Returns nil if block isn't cached into Main Memory or EMS
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_GiveLRUPage() - Returns the page # of the least recently used
src/lib/16_pm.c://		present & unlocked main/EMS page (or main page if mainonly is true)
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_GiveLRUXMSPage() - Returns the page # of the least recently used
src/lib/16_pm.c://		(and present) XMS page.
src/lib/16_pm.c://	This routine won't return the XMS page protected (by XMSProtectPage)
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_PutPageInXMS() - If page isn't in XMS, find LRU XMS page and replace
src/lib/16_pm.c://		it with the main/EMS page
src/lib/16_pm.c://
src/lib/16_pm.c:		return;					// Already in XMS
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_TransferPageSpace() - A page is being replaced, so give the new page
src/lib/16_pm.c://		the old one's address space. Returns the address of the new page.
src/lib/16_pm.c://
src/lib/16_pm.c:	// Copy page that's about to be purged into XMS
src/lib/16_pm.c:	// Get the address, and force EMS into a physical page if necessary
src/lib/16_pm.c:	// Steal the address
src/lib/16_pm.c:	// Mark replaced page as purged
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_GetAPageBuffer() - A page buffer is needed. Either get it from the
src/lib/16_pm.c://		main/EMS free pool, or use PML_GiveLRUPage() to find which page to
src/lib/16_pm.c://		steal the buffer from. Returns a far pointer to the page buffer, and
src/lib/16_pm.c://		sets the fields inside the given page structure appropriately.
src/lib/16_pm.c://		If mainonly is true, free EMS will be ignored, and only main pages
src/lib/16_pm.c://		will be looked at by PML_GiveLRUPage().
src/lib/16_pm.c://
src/lib/16_pm.c:		// There's remaining EMS - use it
src/lib/16_pm.c:		// There's remaining main memory - use it
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_GetPageFromXMS() - If page is in XMS, find LRU main/EMS page and
src/lib/16_pm.c://		replace it with the page from XMS. If mainonly is true, will only
src/lib/16_pm.c://		search for LRU main page.
src/lib/16_pm.c://	XMSProtectPage is set to the page to be retrieved from XMS, so that if
src/lib/16_pm.c://		the page from which we're stealing the main/EMS from isn't in XMS,
src/lib/16_pm.c://		it won't copy over the page that we're trying to get from XMS.
src/lib/16_pm.c://		(pages that are being purged are copied into XMS, if possible)
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PML_LoadPage() - A page is not in main/EMS memory, and it's not in XMS.
src/lib/16_pm.c://		Load it into either main or EMS. If mainonly is true, the page will
src/lib/16_pm.c://		only be loaded into main.
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_GetPage() - Returns the address of the page, loading it if necessary
src/lib/16_pm.c://		First, check if in Main Memory or EMS
src/lib/16_pm.c://		Then, check XMS
src/lib/16_pm.c://		If not in XMS, load into Main Memory or EMS
src/lib/16_pm.c://
src/lib/16_pm.c:#ifdef __DEBUG_2__	// for debugging
src/lib/16_pm.c:		mov	al,10	// bright green
src/lib/16_pm.c:if (!gvar->pm.PMPages[pagenum].offset)	// JDC: sparse page
src/lib/16_pm.c:#ifdef __DEBUG_2__	// for debugging
src/lib/16_pm.c:		mov	al,3	// blue
src/lib/16_pm.c:		mov	al,0x20	// normal
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_SetPageLock() - Sets the lock type on a given page
src/lib/16_pm.c://		pml_Unlocked: Normal, page can be purged
src/lib/16_pm.c://		pml_Locked: Cannot be purged
src/lib/16_pm.c://		pml_EMS?: Same as pml_Locked, but if in EMS, use the physical page
src/lib/16_pm.c://					specified when returning the address. For sound stuff.
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_Preload() - Loads as many pages as possible into all types of memory.
src/lib/16_pm.c://		Calls the update function after each load, indicating the current
src/lib/16_pm.c://		page, and the total pages that need to be loaded (for thermometer).
src/lib/16_pm.c://
src/lib/16_pm.c:	int				i,//j,
src/lib/16_pm.c:					//totalnonxms,totalxms,
src/lib/16_pm.c:					//emstotal,emsfree,
src/lib/16_pm.c:			continue;			// sparse
src/lib/16_pm.c:			continue;			// already in main mem
src/lib/16_pm.c://
src/lib/16_pm.c:// cache main/ems blocks
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c:// load stuff to XMS
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	General code
src/lib/16_pm.c://
src/lib/16_pm.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_NextFrame() - Increments the frame counter and adjusts the thrash
src/lib/16_pm.c://		avoidence variables
src/lib/16_pm.c://
src/lib/16_pm.c://		If currently in panic mode (to avoid thrashing), check to see if the
src/lib/16_pm.c://			appropriate number of frames have passed since the last time that
src/lib/16_pm.c://			we would have thrashed. If so, take us out of panic mode.
src/lib/16_pm.c://
src/lib/16_pm.c://
src/lib/16_pm.c:	// Frame count overrun - kill the LRU hit entries & reset frame count
src/lib/16_pm.c://#if 0
src/lib/16_pm.c://#endif
src/lib/16_pm.c:		// DEBUG - set border color
src/lib/16_pm.c:			// DEBUG - reset border color
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_Reset() - Sets up caching structures
src/lib/16_pm.c://
src/lib/16_pm.c:	// Initialize page list
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_Startup() - Start up the Page Mgr
src/lib/16_pm.c://
src/lib/16_pm.c:	//strcpy(&(gvar->pm.fi.PageFileName), "VSWAP.");
src/lib/16_pm.c:	//0000+=+=PML_OpenPageFile(gvar);
src/lib/16_pm.c:		//return;
src/lib/16_pm.c://
src/lib/16_pm.c://	PM_Shutdown() - Shut down the Page Mgr
src/lib/16_pm.c://
src/lib/16_pm.c:	//PML_ClosePageFile(gvar);
src/lib/16_pm.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_pm.h://
src/lib/16_pm.h://	ID_PM.H
src/lib/16_pm.h://	Header file for Id Engine's Page Manager
src/lib/16_pm.h://
src/lib/16_pm.h:/*//	NOTE! PMPageSize must be an even divisor of EMSPageSize, and >= 1024
src/lib/16_pm.h:#define	PMMinMainMem	10			// Min acceptable # of pages from main
src/lib/16_pm.h:#define	PMMaxMainMem	100			// Max number of pages in main memory
src/lib/16_pm.h:#define	PMThrashThreshold	1	// Number of page thrashes before panic mode
src/lib/16_pm.h:#define	PMUnThrashThreshold	5	// Number of non-thrashing frames before leaving panic mode
src/lib/16_pm.h:			dword	offset;		// Offset of chunk into file
src/lib/16_pm.h:			word		length;		// Length of the chunk
src/lib/16_pm.h:			int			xmsPage;	// If in XMS, (xmsPage * PMPageSize) gives offset into XMS handle
src/lib/16_pm.h:			PMLockType	locked;		// If set, this page can't be purged
src/lib/16_pm.h:			int			emsPage;	// If in EMS, logical page/offset into page
src/lib/16_pm.h:			int			mainPage;	// If in Main, index into handle array
src/lib/16_pm.h:			dword	lastHit;	// Last frame number of hit
src/lib/16_pm.h:			int			baseEMSPage;	// Base EMS page for this phys frame
src/lib/16_pm.h:			dword	lastHit;		// Last frame number of hit
src/lib/16_pm.h:extern	PageListStruct	far *PMPages;*///moved to src/lib/typdefst.h
src/lib/16_pm.h:				PM_GetPage(int pagenum, global_game_variables_t *gvar);		// Use this one to cache page
src/lib/16render.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16render.c://TODO! ADD CLIPPING!!
src/lib/16render.c://memory management needs to be added
src/lib/16render.c://void
src/lib/16render.c://modexDrawBmpRegion	(page_t *page, int x, int y, int rx, int ry, int rw, int rh, bitmap_t *bmp)
src/lib/16render.c:	//fine tuning
src/lib/16render.c:	//^^;
src/lib/16render.c:	//printf("%d,%d p(%d,%d) r(%d,%d) rwh(%d,%d)\n", x, y, px, py, rx, ry, rw, rh);
src/lib/16render.c:// 	byte near *buff;
src/lib/16render.c:// 	buff = _nmalloc(p->pwidth+1);
src/lib/16render.c:	// TODO Make this fast.  It's SLOOOOOOW
src/lib/16render.c:// 	for(plane=0; plane < 4; plane++) {
src/lib/16render.c:// 		i=0;
src/lib/16render.c:// 		modexSelectPlane(PLANE(plane+x));
src/lib/16render.c:// 		for(px = plane; px < p->width; px+=4) {
src/lib/16render.c:// 			offset=px;
src/lib/16render.c:// 			for(py=0; py<p->height/2; py++) {
src/lib/16render.c:// 				//SELECT_ALL_PLANES();
src/lib/16render.c:// 				if(!sprite || p->plane[offset])
src/lib/16render.c:// 					page->data = &(p->plane[offset][i++]);
src/lib/16render.c:// 				offset+=p->width;
src/lib/16render.c:// 				offset++;
src/lib/16render.c:// 			}
src/lib/16render.c:// 		}
src/lib/16render.c:// 	}
src/lib/16render.c:			//for(px=0; px < p->width; px++) {
src/lib/16render.c:				//printf("%02X ", (int) p->plane[plane][i++]);
src/lib/16render.c://				_fmemcpy(buff, &(p->plane[plane][i+=p->pwidth]), p->pwidth);
src/lib/16render.c://				printf("buff %u==%s\n", y, *buff);
src/lib/16render.c://				_fmemcpy(page->data + (((page->width/4) * (y+page->dy)) + ((x+page->dx) / 4)), buff, p->pwidth);
src/lib/16render.c:			//}
src/lib/16render.c://getch();
src/lib/16render.c:// 	_nfree(buff);*/
src/lib/16render.c://* normal versions *//
src/lib/16render.c:	byte *data = bmp->data;//+bmp->offset;
src/lib/16render.c:	byte *data = bmp->data;//+bmp->offset;
src/lib/16render.c://* planar buffer versions *//
src/lib/16render.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_snd.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_snd.c:	//FMSetPercusiveMode(percusiveMode);
src/lib/16_snd.c:	regNum = 0xB0 + voice % 11;//NUMVOICE;
src/lib/16_snd.c:	regNum = 0xA0 + voice % 11;//NUMVOICE;
src/lib/16_snd.c:	regNum = 0xB0 + voice % 11;//NUMVOICE;
src/lib/16_snd.c:	voiceNum %= 11;//NUMVOICE;
src/lib/16_snd.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_sprit.c:	// Retrive animation name list
src/lib/16_sprit.c:	// Upon new animation, start from the first sprite in it
src/lib/16_sprit.c:	// Retruve animation ids list
src/lib/16_sprit.c:	// Loop through animation id untill match or end of list
src/lib/16_sprit.c:		// Return on successful match
src/lib/16_sprit.c:	// Retruve animation ids list
src/lib/16_sprit.c:	// Loop through animation id untill match or end of list
src/lib/16_sprit.c:	// Events go here
src/lib/16_sprit.c:	// Draw sprite
src/lib/16_sprit.c:	// Depending on delay, update indices
src/lib/16_sprit.c:		// Delay = 0 means that sprite should loop. Nothing to change here
src/lib/16_sprit.c:		// Delay = 1 means that on next time unit sprite should be changed
src/lib/16_sprit.c:			// If we hit the end of an animation sequence, restart it
src/lib/16_sprit.c:		// Delay > 1 means that we should not change sprite yet. Decrease delay
src/lib/16_sprit.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_sprit.h:	// VRS container from which we will extract animation and image data
src/lib/16_sprit.h:	// Container for a vrl sprite
src/lib/16_sprit.h:	// Current sprite id
src/lib/16_sprit.h:	// Index of a current sprite in an animation sequence
src/lib/16_sprit.h:	// Current animation sequence
src/lib/16_sprit.h:	// Index of current animation in relevant VRS offsets table
src/lib/16_sprit.h:	// Delay in time units untill we should change sprite
src/lib/16_sprit.h:	// Position of sprite on screen
src/lib/16_tail.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_tail.c:	// DOSLIB: check our environment
src/lib/16_tail.c:	// DOSLIB: what CPU are we using?
src/lib/16_tail.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/lib/16_tail.c:	//      So this code by itself shouldn't care too much what CPU it's running on. Except that other
src/lib/16_tail.c:	//      parts of this project (DOSLIB itself) rely on CPU detection to know what is appropriate for
src/lib/16_tail.c:	//      the CPU to carry out tasks. --J.C.
src/lib/16_tail.c:	// DOSLIB: check for VGA
src/lib/16_tail.c:	// hardware must be VGA or higher!
src/lib/16_tail.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/lib/16_tail.c://===========================================================================
src/lib/16_tail.c://===========================================================================
src/lib/16_tail.c:	//unsigned        finscreen;
src/lib/16_tail.c:	//ClearMemory ();
src/lib/16_tail.c:	 //WriteConfig ();
src/lib/16_tail.c:	 //CA_CacheGrChunk (ERRORSCREEN);
src/lib/16_tail.c:	 //screen = grsegs[ERRORSCREEN];
src/lib/16_tail.c:	//ShutdownId ();
src/lib/16_tail.c:	//modexLeave();
src/lib/16_tail.c:	  //movedata ((unsigned)screen,7,0xb800,0,7*160);
src/lib/16_tail.c:	  //gotoxy (10,4);
src/lib/16_tail.c:	  //gotoxy (1,8);
src/lib/16_tail.c:		//clrscr();
src/lib/16_tail.c:		//#ifndef JAPAN
src/lib/16_tail.c:		//gotoxy(1,24);
src/lib/16_tail.c:		//#endif
src/lib/16_tail.c://asm	mov	bh,0
src/lib/16_tail.c://asm	mov	dh,23	// row
src/lib/16_tail.c://asm	mov	dl,0	// collumn
src/lib/16_tail.c://asm	mov ah,2
src/lib/16_tail.c://asm	int	0x10
src/lib/16_tail.c://===========================================================================
src/lib/16_tail.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16text.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16text.c:	//romFontsData
src/lib/16text.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16text.h:    word  seg;       //segment for the font
src/lib/16text.h:    word  off;       //offset in the segment for the font
src/lib/16text.h:    byte  charSize;  //bytes in each character
src/lib/16text.h:	byte col;	//color
src/lib/16text.h:	byte bgcol;		//bg color!
src/lib/16text.h:	word chw;		//char width
src/lib/16_timer.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_timer.c:	//gv->kurokku.frames_per_second = 60;
src/lib/16_timer.c:    //turn this off if XT
src/lib/16_timer.c:// big global status text buffer
src/lib/16_timer.c:	//float t;
src/lib/16_timer.c:		//t=(((*(gv->clock))-gv->clock_start) /18.2);
src/lib/16_timer.c:		//(gv->clock_start)=*(gv->clock);
src/lib/16_timer.c:// 	switch(gv->kurokku.fpscap)
src/lib/16_timer.c:// 	{
src/lib/16_timer.c:// 		case 0:
src/lib/16_timer.c:// 			gv->kurokku.frames_per_second=1;
src/lib/16_timer.c:// 		break;
src/lib/16_timer.c:// 		case 1:
src/lib/16_timer.c:// 			//turn this off if XT
src/lib/16_timer.c:// 			WaitPee();
src/lib/16_timer.c:// 			gv->kurokku.frames_per_second=60;
src/lib/16_timer.c:// 		break;
src/lib/16_timer.c:// 	}
src/lib/16_timer.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_timer.h://double time_in_seconds(time_t in_t);
src/lib/16_vl.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_vl.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_vl.c://																														//
src/lib/16_vl.c:// setvideo() - This function Manages the video modes												//
src/lib/16_vl.c://																														//
src/lib/16_vl.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_vl.c:		case 0: // deinit the video
src/lib/16_vl.c:			// change to the video mode we were in before we switched to mode 13h
src/lib/16_vl.c:		default: // init the video
src/lib/16_vl.c:			// get old video mode
src/lib/16_vl.c:			//in.h.ah = 0xf;
src/lib/16_vl.c:			//int86(0x10, &in, &out);
src/lib/16_vl.c:			gv->video.old_mode = vgaGetMode();//out.h.al;
src/lib/16_vl.c:			// enter mode
src/lib/16_vl.c:  //int10_setmode(mode);
src/lib/16_vl.c://---------------------------------------------------
src/lib/16_vl.c://
src/lib/16_vl.c:// Use the bios to get the current video mode
src/lib/16_vl.c://
src/lib/16_vl.c:	//int CRTParmCount;
src/lib/16_vl.c:	//outp(CRTC_INDEX, 0x11); /* VSync End reg contains register write prot */
src/lib/16_vl.c:	//outp(CRTC_DATA, 0x7f);  /* get current write protect on varios regs */
src/lib/16_vl.c:			//CRTParmCount = sizeof(ModeX_320x240regs) / sizeof(ModeX_320x240regs[0]);
src/lib/16_vl.c:			gv->video.page[0].sw = vga_state.vga_width = 320; // VGA lib currently does not update this
src/lib/16_vl.c:			gv->video.page[0].sh = vga_state.vga_height = 240; // VGA lib currently does not update this
src/lib/16_vl.c:			// mode X BYTE mode
src/lib/16_vl.c:			// 320x240 mode 60Hz
src/lib/16_vl.c://			cm.horizontal_blank_end=0x82 + 1;   /* CRTC[3] bit 0-4 & CRTC[5] bit 7 *///skewing ^^;
src/lib/16_vl.c:			//cm.horizontal_start_delay_after_total=0x3e; /* CRTC[3] bit 5-6 */
src/lib/16_vl.c:			//cm.horizontal_start_delay_after_retrace=0x41; /* CRTC[5] bit 5-6 */
src/lib/16_vl.c:			cm.offset = (vga_state.vga_width / (4 * 2)); // 320 wide (40 x 4 pixel groups x 2)
src/lib/16_vl.c:		case 2: // TODO: 160x120 according to ModeX_160x120regs
src/lib/16_vl.c:		case 3: // TODO: 160x120 according to ModeX_320x200regs
src/lib/16_vl.c:		case 4: // TODO: 160x120 according to ModeX_192x144regs
src/lib/16_vl.c:		case 5: // TODO: 160x120 according to ModeX_256x192regs
src/lib/16_vl.c:			dword far*ptr=(dword far*)vga_state.vga_graphics_ram;//VGA;	  /* used for faster screen clearing */
src/lib/16_vl.c:			for(i = 0;i < 0x4000; i++) ptr[i] = 0x0000; // 0x4000 x dword = 64KB
src/lib/16_vl.c://	gv->video.page[0].tw = gv->video.page[0].sw/TILEWH;
src/lib/16_vl.c://	gv->video.page[0].th = gv->video.page[0].sh/TILEWH;
src/lib/16_vl.c:	//TODO MAKE FLEXIBLE~
src/lib/16_vl.c://	gv->video.page[0].tilemidposscreenx = gv->video.page[0].tilesw;
src/lib/16_vl.c://	gv->video.page[0].tilemidposscreeny = (gv->video.page[0].tilesh/2)+1;
src/lib/16_vl.c:	//page.data = VGA;
src/lib/16_vl.c:	//page.data = (byte far *)(vga_state.vga_graphics_ram);
src/lib/16_vl.c://next page with defined dimentions~
src/lib/16_vl.c:	result.stridew=p->sw/4;//result.width/4;
src/lib/16_vl.c:	//printf("\n\n	1st vmem_remain=%u\n", video->vmem_remain);
src/lib/16_vl.c:		//printf("		[%u], video->page[%u].pagesize=%u\n", i, i, video->page[i].pagesize);
src/lib/16_vl.c:		//printf("		[%u], vmem_remain=%u\n", i, video->vmem_remain);
src/lib/16_vl.c:	(video->page[0]) = modexDefaultPage(&(video->page[0]));	video->num_of_pages++;	//video->page[0].width += (TILEWHD); video->page[0].height += (TILEWHD);
src/lib/16_vl.c://0000	(video->page[2]) = modexNextPageFlexibleSize(&(video->page[1]), (video->page[0]).width, TILEWH*4);		video->num_of_pages++;
src/lib/16_vl.c://0000	(video->page[3]) = (video->page[2]);		video->num_of_pages++;
src/lib/16_vl.c://	(video->page[3]) = modexNextPageFlexibleSize(&(video->page[2]), video->page[0].width, 176);	video->num_of_pages++;
src/lib/16_vl.c:// 	(video->page[2]) = modexNextPageFlexibleSize(&(video->page[1]), video->page[0].width, 172);	video->num_of_pages++;
src/lib/16_vl.c:// 	(video->page[3]) = modexNextPageFlexibleSize(&(video->page[2]), 72, 128);		video->num_of_pages++;
src/lib/16_vl.c:	//while ((inp(INPUT_STATUS_1) & DISPLAY_ENABLE));
src/lib/16_vl.c:	//while (!(inp(INPUT_STATUS_1) & VRETRACE));
src/lib/16_vl.c:	//printf("modexClearRegion(x=%u, y=%u, w=%u, h=%u, left=%u, right=%u)\n", x, y, w, h, left, right);
src/lib/16_vl.c:	word scans   = vga_state.vga_stride;				//++++0000 the quick and dirty fix of the major issue with p16 video display wwww
src/lib/16_vl.c://	printf("modexCopyPageRegion(src->stridew=%u, dest->stridew=%u, sx=%u, sy=%u, dx=%u, dy=%u, width=%u, height=%u, left=%u, right=%u)\n", src->stridew, dest->stridew, sx, sy, dx, dy, width, height, left, right);
src/lib/16_vl.c:	//unsigned int i;
src/lib/16_vl.c:	static word a[PAL_SIZE];	//palette array of change values!
src/lib/16_vl.c:	//modexWaitBorder();
src/lib/16_vl.c://		  printf("q: %02d\n", (q));
src/lib/16_vl.c://		  printf("qq: %02d\n", (qq));
src/lib/16_vl.c:		//printf("	  (*i)-q=%02d\n", (*i)-q);
src/lib/16_vl.c:			//if(i%3==0 && (p[i+5]==p[i+4] && p[i+4]==p[i+3] && p[i+3]==p[i+2] && p[i+2]==p[i+1] && p[i+1]==p[i] && p[i+5]==p[i]))
src/lib/16_vl.c://____		  if((qp>0)&&((*i)-q)%3==0 && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5])) outp(PAL_DATA_REG, p[(*i)-q]); else
src/lib/16_vl.c:				//printf("qp=%d\n", qp);
src/lib/16_vl.c:				//printf("		  (*i)=%d a[%d]=%d\n", (*i), qp, a[qp]);
src/lib/16_vl.c:				//outp(PAL_DATA_REG, p[((a[qp])-(bmp->offset*3)+qp)]);// fix this shit!
src/lib/16_vl.c:				else{ //outp(PAL_DATA_REG, p[((*i)-(bmp->offset*3)+qp)]);
src/lib/16_vl.c:		//if(qp>0) printf("qp=%d\n", qp);
src/lib/16_vl.c:		//if(qp>0) printf("						 (*i)=%d\n", (*i)/3);
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c://____		  if((qp>0)&&((*i)-q)%3==0 && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5])) outp(PAL_DATA_REG, p[(*i)-q]); else
src/lib/16_vl.c:				//printf("qp=%d\n", qp);
src/lib/16_vl.c:				//printf("		  (*i)=%d a[%d]=%d\n", (*i), qp, a[qp]);
src/lib/16_vl.c:				//outp(PAL_DATA_REG, p[((a[qp])-(bmp->offset*3)+qp)]);// fix this shit!
src/lib/16_vl.c:				else{ //outp(PAL_DATA_REG, p[((*i)-(bmp->offset*3)+qp)]);
src/lib/16_vl.c:		//printf("						  (*i)=%d\n", (*i)/3);
src/lib/16_vl.c:	//palette checker~
src/lib/16_vl.c:		//printf("1(*i)=%02d\n", (*i)/3);
src/lib/16_vl.c:		//printf("1z=%02d\n", z/3);
src/lib/16_vl.c:		//printf("2(*i)=%02d\n", (*i)/3);
src/lib/16_vl.c:		//printf("2z=%02d\n", z/3);
src/lib/16_vl.c://			  printf("a[%02d]=(%d)\n", aq, a[aq]);
src/lib/16_vl.c://update the image data here!
src/lib/16_vl.c:		//(offset/bmp->offset)*bmp->offset
src/lib/16_vl.c:		//printf("%02d ",bmp->data[lq]+bmp->offset);
src/lib/16_vl.c:		//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c:		//printf("%02d_", bmp->data[lq]+bmp->offset);
src/lib/16_vl.c:			//printf("%02d", bmp->data[lq]);
src/lib/16_vl.c:			//printf("\n%02d\n", bmp->offset);
src/lib/16_vl.c:			//bmp->data[lq]=((bmp->data[lq]+bmp->offset)-a[aq]);
src/lib/16_vl.c://++++		  bmp->data[lq]=a[aq]-aqpp;
src/lib/16_vl.c://			  printf("_%d ", bmp->data[lq]);
src/lib/16_vl.c:			//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c:				bmp->data[lq]=(bmp->data[lq]+bmp->offset)-aqpp;//-((z-(*i))/3);
src/lib/16_vl.c:				//printf("_%d ", bmp->data[lq]+bmp->offset)-aqpp-((z-(*i))/3);
src/lib/16_vl.c:		//printf("%02d`", bmp->data[lq]);
src/lib/16_vl.c:		//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c://printf("		  aq=%02d\n", aq);
src/lib/16_vl.c://printf("		  aa=%02d\n", aa);
src/lib/16_vl.c:	//update the palette~
src/lib/16_vl.c:	//modexWaitBorder();
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c:	//modexWaitBorder();
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c:	//modexWaitBorder();
src/lib/16_vl.c://color checker~
src/lib/16_vl.c://i want to make another vesion that checks the palette when the palette is being appened~
src/lib/16_vl.c:		//printf("q: %02d\n", (*q));
src/lib/16_vl.c://		  printf("1 offset of color in palette	(*q): %d\n", (*q)/3);
src/lib/16_vl.c:		//check palette for dups
src/lib/16_vl.c:			//printf("\n		z: %d\n", (*z));
src/lib/16_vl.c:			//printf("		  q: %d\n", (*q));
src/lib/16_vl.c:			//printf("		  z+q: %d\n\n", ((*z)+(*q)));
src/lib/16_vl.c:			//if((*z)%3==0)
src/lib/16_vl.c:			//{
src/lib/16_vl.c://----			  if(pal[(*z)]==pal[(*z)+3] && pal[(*z)+1]==pal[(*z)+4] && pal[(*z)+2]==pal[(*z)+5])
src/lib/16_vl.c://					  printf("\n%d	[%02d][%02d][%02d]\n", (*z), pal[(*z)], pal[(*z)+1], pal[(*z)+2]);
src/lib/16_vl.c://					  printf("%d	  [%02d][%02d][%02d]\n\n", (*z)+3, pal[(*z)+3], pal[(*z)+4], pal[(*z)+5]);
src/lib/16_vl.c://0000				  (*z)-=3;
src/lib/16_vl.c:					//printf("zz: %02d\n", zz/3);
src/lib/16_vl.c:						if(pal[((*z)+(*q))]==pal[((*z)+(*q))+3] && pal[((*z)+(*q))+1]==pal[((*z)+(*q))+4] && pal[((*z)+(*q))+2]==pal[((*z)+(*q))+5])	//break if duplicate colors found in palette because it have reached the end of the current data of the palette
src/lib/16_vl.c://							  (*z)-=3;
src/lib/16_vl.c://							  (*i)-=3;
src/lib/16_vl.c://							  printf("\nzq1:%d[%02d][%02d][%02d]\n", (zz+q), pal[(zz+q)], pal[(zz+q)+1], pal[(zz+q)+2]);
src/lib/16_vl.c://							  printf("zq2:%d[%02d][%02d][%02d]\n\n", (zz+q)+3, pal[(zz+q)+3], pal[(zz+q)+4], pal[(zz+q)+5]);
src/lib/16_vl.c://							  printf("\n\nwwwwwwwwwwwwwwww\n");
src/lib/16_vl.c://							  printf("	zq: %d  [%02d][%02d][%02d] value that is needing to be changed~\n", ((*z)+(*q))/3, pal[((*z)+(*q))], pal[((*z)+(*q))+1], pal[((*z)+(*q))+2]);
src/lib/16_vl.c://							  printf("	zz: %d  [%02d][%02d][%02d] value that the previous value is going to change to~\n", (zz)/3, pal[zz], pal[zz+1], pal[zz+2]);
src/lib/16_vl.c://							  //printf("	  zv: %d  [%02d][%02d][%02d] wwww\n", (zz-z+q)/3, pal[(zz-z+q)], pal[(zz-z+q)+1], pal[(zz-z+q)+2]);
src/lib/16_vl.c://							  printf("	z : %d  [%02d][%02d][%02d] offset value~\n", (*z)/3, pal[(*z)], pal[(*z)+1], pal[(*z)+2]);
src/lib/16_vl.c://++++						  (*i)--;
src/lib/16_vl.c://							  (*z)--;
src/lib/16_vl.c:							//expand dong here
src/lib/16_vl.c:							//for(zzii=0; zzii<3; zzii++)
src/lib/16_vl.c:							//{
src/lib/16_vl.c:								//printf("z+q: %d\n\n", ((*z)+(*q)));
src/lib/16_vl.c:							//}
src/lib/16_vl.c://							  printf("\n		  aa: %d\n\n", (*aa));
src/lib/16_vl.c://							  printf("	a[%02d]=(%02d) offset array i think the palette should be updated again~\n", ((*z)+(*q))/3, a[((*z)+(*q))/3]);
src/lib/16_vl.c://							  printf("wwwwwwwwwwwwwwww\n\n");
src/lib/16_vl.c:						//printf("[%d]", (zz+q));
src/lib/16_vl.c://		  printf("2 offset of color in palette	(*q): %d\n", (*q)/3);
src/lib/16_vl.c:	//outp(SC_INDEX, 0x02);
src/lib/16_vl.c:	//outp(SC_DATA, 0x01 << (x & 3));
src/lib/16_vl.c:	m1 = 0x80; // left half
src/lib/16_vl.c:	m2 = 0x08; // right half
src/lib/16_vl.c:	//word addr = (word) romFontsData.l;
src/lib/16_vl.c:	// load the character into romFontsData.l
src/lib/16_vl.c:	// no need for inline assembly!
src/lib/16_vl.c:	// NTS: It might even be faster to just let the modexDrawChar point directly at ROM font than to copy per char! --J.C.
src/lib/16_vl.c:	//load the letter 'A'
src/lib/16_vl.c:				//modexputPixel(page, x+xp+chw, y+i, l[i] & j ? col:bgcol);
src/lib/16_vl.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_vl.c://																		 //
src/lib/16_vl.c:// cls() - This clears the screen to the specified color, on the VGA or on //
src/lib/16_vl.c://		 the Virtual screen.											 //
src/lib/16_vl.c://																		 //
src/lib/16_vl.c://///////////////////////////////////////////////////////////////////////////
src/lib/16_vl.c:	//modexClearRegion(page, 0, 0, page->width, page->height, color);
src/lib/16_vl.c:	//_fmemset(VGA, color, 16000);
src/lib/16_vl.c:	// spin
src/lib/16_vl.c:	//spin
src/lib/16_vl.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_vl.h://#include "src/lib/planar.h"
src/lib/16_vl.h://#include "src/lib/modex16/16planar.h"
src/lib/16_vl.h:////#include "src/lib/modex16/320x240.h"
src/lib/16_vl.h:// #include "src/lib/modex16/320x200.h"
src/lib/16_vl.h:// #include "src/lib/modex16/256x192.h"
src/lib/16_vl.h:// #include "src/lib/modex16/192x144_.h"
src/lib/16_vl.h:// #include "src/lib/modex16/160x120.h"
src/lib/16_vl.h://320x240 = 20x15
src/lib/16_vl.h://192x144 = 12x9
src/lib/16_vl.h://temp defines
src/lib/16_vl.h://#define INPUT_STATUS_1		0x03da	defined in 16_head
src/lib/16_vl.h:#if 0 // not needed anymore. maybe good for reference purposes though.
src/lib/16_vl.h:	//outp(SC_INDEX, 0x02);
src/lib/16_vl.h:	//outp(SC_DATA, 0x01 << (x & 3));
src/lib/16_vrs.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_vrs.c:// Read .vrs file into far memory
src/lib/16_vrs.c:	// Open filename, get size of file,
src/lib/16_vrs.c:	// populate the vrs_container if all tests pass
src/lib/16_vrs.c:	// Insert sanity cheks later
src/lib/16_vrs.c:	// Calculate vrl offsets
src/lib/16_vrs.c:	// Count sprites
src/lib/16_vrs.c:	// Allocate memory for vrl line offsets table
src/lib/16_vrs.c:	// Calculate line offsets for each vrl
src/lib/16_vrs.c:		// Calc. vrl size as (next_offset - curr_offset)
src/lib/16_vrs.c:		// If it's the last vrl, size is (next_vrs_struct_offset - curr_offset)
src/lib/16_vrs.c:// Seek and return a specified .vrl blob from .vrs blob in far memory
src/lib/16_vrs.c:	// If id is invalid, return -1
src/lib/16_vrs.c:		// Probably add an error message?
src/lib/16_vrs.c:	// Get id list from .vrs blob (base + offset)
src/lib/16_vrs.c:	// Loop through the id list until we found the right one or hit the end of the list
src/lib/16_vrs.c:	// Counter is keeping track of the offset(in ids/vrl blobs)
src/lib/16_vrs.c:	// Return -2 if we couldn't find the requested id
src/lib/16_vrs.c:		// Error message?
src/lib/16_vrs.c:	// Get vrl offsets list from .vrs blob (base + offset)
src/lib/16_vrs.c:	// Get vrl_header from .vrs (base + offset from vrl_list)
src/lib/16_vrs.c:	// Counter is number of vrls to skip (ids and vrls are aligned according to the .vrs specification)
src/lib/16_vrs.c:	// Get .vrl size by integer arithmetics (next vrl offset - current vrl offset)
src/lib/16_vrs.c:	// If we are retriving the last vrl, size is ids_list offset - current vrl offset, as next vrl offs is 0
src/lib/16_vrs.c:	// Retrive line offsets form .vrs
src/lib/16_vrs.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/16_vrs.h://#include <hw/cpu/cpu.h>
src/lib/16_vrs.h://#include <hw/dos/dos.h>
src/lib/16_vrs.h:	// Size of a .vrs lob in memory
src/lib/16_vrs.h:	// minus header
src/lib/16_vrs.h:	// Array of corresponding vrl line offsets
src/lib/16_vrs.h:	// Size of a .vrl blob in memory
src/lib/16_vrs.h:	// minus header
src/lib/16_vrs.h:	// Pointer to a corresponding vrl line offsets struct
src/lib/bakapee.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/bakapee.c://color 
src/lib/bakapee.c:	//if(pee->coor < 256)
src/lib/bakapee.c:	//{
src/lib/bakapee.c:	//}else pee->coor = 0;
src/lib/bakapee.c://color 
src/lib/bakapee.c://slow spectrum down
src/lib/bakapee.c:			//mxPutPixel(sx, sy, coor);
src/lib/bakapee.c:			//printf("%d %d %d %d\n", pee->sx, pee->sy, svq, pee->coor);
src/lib/bakapee.c://plot pixel or plot tile
src/lib/bakapee.c:	//fill_block(pee->xx, pee->yy, pee->xx+TILEWH, pee->yy+TILEWH, pee->coor);
src/lib/bakapee.c://assigning values from randomizer
src/lib/bakapee.c://randomizer
src/lib/bakapee.c://++++  if(q <= 4 && q!=2 && gq == BONK-1) coor = rand()%HGQ;
src/lib/bakapee.c:			dingpp(page, pee);	//plot the pixel/tile
src/lib/bakapee.c:			dingpp(page, pee);	//plot the pixel/tile
src/lib/bakapee.c:			dingpp(page, pee);	//plot the pixel/tile
src/lib/bakapee.c:		case 16:	//interesting effects
src/lib/bakapee.c:			//printf("%d %d %d %d %d %d\n", pee->xx, pee->yy, tx, ty, TILEWH);
src/lib/bakapee.c:	//pee->coor++;
src/lib/bakapee.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/bakapee.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/bakapee.h://#include "src/lib/modex/modex.h"
src/lib/bakapee.h://#include "16/x/modex.h"
src/lib/bakapee.h://which lib?
src/lib/bitmap.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/bitmap.c:	//long bufSize;
src/lib/bitmap.c:	//int index;
src/lib/bitmap.c:	//byte count, val;
src/lib/bitmap.c:	//long int pos;
src/lib/bitmap.c:	//printf("%zu\n", _memmax());
src/lib/bitmap.c://	result.data = (byte far *)_fmalloc(bufSize);
src/lib/bitmap.c://	result.data = (byte __huge *)halloc(bufSize, sizeof(byte));
src/lib/bitmap.c:	//exit(0);
src/lib/bitmap.c:	//printf("index=%d\n", index);
src/lib/bitmap.c://TODO: update!!
src/lib/bitmap.c:	//ts.data[0] = malloc(sizeof(byte) * ts.ntiles * twidth * theight);
src/lib/bitmap.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/ems.c:          sregs.ds = 0; //????
src/lib/mapread.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/mapread.c://this function is quite messy ^^; sorry! it is a quick and dirty fix~
src/lib/mapread.c:	word j;//, k;
src/lib/mapread.c://0000fprintf(stderr, "t->type=%d\n", t->type);
src/lib/mapread.c://			fprintf(stdout, "[[[[%d|%d]]]]\n", &(t+1)->size, (t+1)->size);
src/lib/mapread.c://			fprintf(stdout, "\n%.*s[xx[%d|%d]xx]\n", (t+1)->end - (t+1)->start, js+(t+1)->start, &(t+1)->size, (t+1)->size);
src/lib/mapread.c:			//fix this to be far~
src/lib/mapread.c://0000			bp = bitmapLoadPcx("data/ed.pcx");
src/lib/mapread.c://			bp = bitmapLoadPcx("data/koishi^^.pcx");
src/lib/mapread.c://----			map->tiles->data = planar_buf_from_bitmap(&bp);
src/lib/mapread.c:			//map->tiles->data->data = malloc((16/**2*/)*16);
src/lib/mapread.c:			//map->tiles->data->width = (16/**2*/);
src/lib/mapread.c:			//map->tiles->data->height= 16;
src/lib/mapread.c:			strcpy(js_sv, "data");//strdup(js+t->start);//, t->end - t->start);
src/lib/mapread.c:			strcpy(js_sv, "height");//strdup(js+t->start);//, t->end - t->start);
src/lib/mapread.c:			strcpy(js_sv, "width");//strdup(js+t->start);//, t->end - t->start);
src/lib/mapread.c:		//fprintf(stdout, "\n");
src/lib/mapread.c:			//for (k = 0; k < indent; k++) fprintf(stdout, "\t");
src/lib/mapread.c:			//fprintf(stdout, ": ");
src/lib/mapread.c:			//fprintf(stdout, "\n");
src/lib/mapread.c:		//fprintf(stdout, "==\n");
src/lib/mapread.c:			//for (k = 0; k < indent-1; k++) fprintf(stdout, "\t");
src/lib/mapread.c:			//fprintf(stdout, "\t-");
src/lib/mapread.c:			//fprintf(stdout, "==\n");
src/lib/mapread.c://0000fprintf(stderr, "tok malloc\n");
src/lib/mapread.c://0000fprintf(stderr, "read\n");
src/lib/mapread.c://0000fprintf(stdout, "r=	[%d]	BUFSIZ=%d\n", r, BUFSIZ);
src/lib/mapread.c://0000fprintf(stderr, "js alloc~\n");
src/lib/mapread.c://0000fprintf(stdout, "	parse~ tok=%zu	jslen=%zu	r=%d	_memavl()=%u	BUFSIZ=%d~\n", tokcount, jslen, r, _memavl(), BUFSIZ);
src/lib/mapread.c://0000fprintf(stdout, "p=[%u]	[%u]	[%d]\n", p.pos, p.toknext, p.toksuper);
src/lib/mapread.c://0000fprintf(stdout, "r=	[%d]\n", r);
src/lib/mapread.c://0000fprintf(stderr, "tok realloc~ %zu\n", tokcount);
src/lib/mapread.c:			//printf("js=%Fp\n", (js));
src/lib/mapread.c:			//printf("*js=%Fp\n", (*(js)));
src/lib/mapread.c:			//printf("&*js=%s\n", &(*(js)));
src/lib/mapread.c:			//printf("&buf=[%Fp]\n", &buf);
src/lib/mapread.c:			//printf("&buf_seg=[%x]\n", FP_SEG(&buf));
src/lib/mapread.c:			//printf("&buf_off=[%x]\n", FP_OFF(&buf));
src/lib/mapread.c:			//printf("&buf_fp=[%Fp]\n", MK_FP(FP_SEG(&buf), FP_OFF(&buf)));
src/lib/mapread.c:			//printf("buf=[\n%s\n]\n", buf);
src/lib/mapread.c:			//printf("buff=[%Fp]\n", buff);
src/lib/mapread.c:			//printf("(*buff)=[%Fp]\n", (*buff));
src/lib/mapread.c:			//printf("&(*buff)=[\n%s\n]\n", &(*buff));
src/lib/mapread.c:	//free(js);
src/lib/mapread.c:	//free(tok);
src/lib/mapread.c:	//fclose(fh);
src/lib/mapread.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/mapread.h://#define DEBUG_MAPDATA
src/lib/mapread.h://#define DEBUG_MAPVAR
src/lib/mapread.h://#define DEBUG_DUMPVARS
src/lib/mapread.h://#define DEBUG_JS
src/lib/mapread.h:	boolean debug_text;	//show the value of the tile! wwww
src/lib/mapread.h:	int width;	//this has to be signed!
src/lib/mapread.h:	int height;	//this has to be signed!
src/lib/midi.c://====
src/lib/midi.c://====
src/lib/midi.c://====
src/lib/midi.c://====
src/lib/midi.c://====
src/lib/midi.c://====
src/lib/midi.c://void adlib_shut_up();
src/lib/midi.c://	midi_tick();
src/lib/midi.h://#include "src/lib/doslib/vga.h"
src/lib/midi.h://#include "src/lib/doslib/vgagui.h"
src/lib/midi.h://#include "src/lib/doslib/vgatty.h"
src/lib/scroll16.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/scroll16.c:	//printf("player[%d].d=%d\n", pn, player[pn].d);
src/lib/scroll16.c:		//no direction
src/lib/scroll16.c:			//0000pip[0].video->startclk = (*clockw);
src/lib/scroll16.c:		//right movement
src/lib/scroll16.c:			//printf("pip[0].page->tilesw=%d	", pip[0].page->tilesw); printf("pip[0].page->tw=%d\n", pip[0].page->tw);
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx+1 == TRIGGX && player[pn].ty == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].tx < pip[0].map->width && !(pip[0].map->data[(player[pn].tx)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx+1 == TRIGGX && player[pn].ty == TRIGGY))
src/lib/scroll16.c:		//left movement
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-2)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx-1 == TRIGGX && player[pn].ty == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].tx > 1 && !(pip[0].map->data[(player[pn].tx-2)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx-1 == TRIGGX && player[pn].ty == TRIGGY))
src/lib/scroll16.c:		//down movement
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty+1 == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].ty < pip[0].map->height && !(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty+1 == TRIGGY))
src/lib/scroll16.c:		//up movement
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty-2))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty-1 == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].ty > 1 && !(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty-2))] == 0))//!(player[pn].tx == TRIGGX &&  player[pn].ty-1 == TRIGGY))
src/lib/scroll16.c://panning page
src/lib/scroll16.c:		//right movement
src/lib/scroll16.c:		//left movement
src/lib/scroll16.c:		//down movement
src/lib/scroll16.c:		//up movement
src/lib/scroll16.c:	//if (player[pn].d!=2) printf("player[%u].d=%u player[%u].q=%u\n", pn, player[pn].d, pn, player[pn].q);
src/lib/scroll16.c:	//result.data = (byte *)alloc_emem(((int)sizeof(byte) * w * h)/1024);
src/lib/scroll16.c:		//emmhandle = mallocEMS(coretotalEMS());//alloc_emem((int)sizeof(map))
src/lib/scroll16.c:	// just a place holder to fill out an alternating pattern
src/lib/scroll16.c://	int tile = 1;
src/lib/scroll16.c:	//if(!isEMS() || !checkEMS())
src/lib/scroll16.c://		map->tiles = malloc(sizeof(tiles_t));
src/lib/scroll16.c:	//else
src/lib/scroll16.c:	//	map->tiles = (tiles_t *)alloc_emem(sizeof(tiles_t));
src/lib/scroll16.c:	 //create the tile set
src/lib/scroll16.c:	//if(!isEMS() || !checkEMS())
src/lib/scroll16.c://		map->tiles->data = malloc(sizeof(bitmap_t));
src/lib/scroll16.c:	//else
src/lib/scroll16.c:	//	map->tiles->data = (bitmap_t *)alloc_emem(sizeof(bitmap_t));
src/lib/scroll16.c://	map->tiles->data->width = (TILEWH);
src/lib/scroll16.c://	map->tiles->data->height= TILEWH;
src/lib/scroll16.c:	//if(!isEMS() || !checkEMS())
src/lib/scroll16.c://		map->tiles->data->data = malloc((TILEWH*2)*TILEWH);
src/lib/scroll16.c:	//else
src/lib/scroll16.c:	//	map->tiles->data->data = (byte *)alloc_emem((TILEWH*2)*TILEWH);
src/lib/scroll16.c://	map->tiles->tileHeight = TILEWH;
src/lib/scroll16.c://	map->tiles->tileWidth =TILEWH;
src/lib/scroll16.c://	map->tiles->rows = 1;
src/lib/scroll16.c://	map->tiles->cols = 1;//2;
src/lib/scroll16.c:	//for(y=0; y<map->height; y++) {
src/lib/scroll16.c:	//for(x=0; x<map->width; x++) {
src/lib/scroll16.c:		//if(x<TILEWH){
src/lib/scroll16.c:		  map->tiles->data->data[i+1] = map->data[q];//28;//0x24;
src/lib/scroll16.c://		  printf("[%d]", map->tiles->data->data[i]);
src/lib/scroll16.c:		//}else{
src/lib/scroll16.c:		  //map->tiles->data->data[i] = map->data[q];//0;//0x34;
src/lib/scroll16.c:		  //printf("]%d[==[%d]", i, map->tiles->data->data[i]);
src/lib/scroll16.c:		//}
src/lib/scroll16.c://	printf("\n");
src/lib/scroll16.c://	printf("[%d]", map->data[q]);
src/lib/scroll16.c://	}
src/lib/scroll16.c:	//printf("\n\n");
src/lib/scroll16.c://	}
src/lib/scroll16.c://			map->data[i]=255;
src/lib/scroll16.c:			//tile = tile ? 0 : 1;
src/lib/scroll16.c:		//tile = tile ? 0 : 1;
src/lib/scroll16.c:	word x;//, y;  /* coordinate for drawing */
src/lib/scroll16.c:	word x;//,y;  /* coordinate for drawing */
src/lib/scroll16.c:	word y;//x,  /* coordinate for drawing */
src/lib/scroll16.c:	word y;//x,  /* coordinate for drawing */
src/lib/scroll16.c://TODO finish this wwww
src/lib/scroll16.c:// 		vga_setup_wm1_block_copy();
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data+4, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:// 		vga_restore_rm0wm0();
src/lib/scroll16.c:// 		vga_setup_wm1_block_copy();
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data-4, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:// 		vga_restore_rm0wm0();
src/lib/scroll16.c:// 		vga_setup_wm1_block_copy();
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data-mv[id].page->pi, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:// 		vga_restore_rm0wm0();
src/lib/scroll16.c:// 		vga_setup_wm1_block_copy();
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data+mv[id].page->pi, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:// 		vga_restore_rm0wm0();
src/lib/scroll16.c://	bitmap_t bp;
src/lib/scroll16.c:	//check for failed to load map
src/lib/scroll16.c:		//initiate a null map!
src/lib/scroll16.c:		map->width=MAPW;///2;
src/lib/scroll16.c:		map->height=MAPH;///2;
src/lib/scroll16.c://		map->data = malloc(((map->width*map->height)+1)*sizeof(byte));
src/lib/scroll16.c:		//fix this to be far~
src/lib/scroll16.c://		bp = bitmapLoadPcx("data/ed.pcx");
src/lib/scroll16.c://		map->tiles->data = &bp;
src/lib/scroll16.c://TODO: player position here
src/lib/scroll16.c:	int py;//px,
src/lib/scroll16.c:// 	{
src/lib/scroll16.c:// 		unsigned int k,j,o;
src/lib/scroll16.c:// 		/* fill screen with a distinctive pattern */
src/lib/scroll16.c:// 		for (k=0;k < vga_state.vga_width;k++) {
src/lib/scroll16.c:// 			o = k >> 2;
src/lib/scroll16.c:// 			vga_write_sequencer(0x02/*map mask*/,1 << (k&3));
src/lib/scroll16.c:// 				for (j=0;j < (mv[0].page->height)+(mv[1].page->height)+(mv[2].page->height)+(mv[3].page->height);j++,o += vga_state.vga_stride)
src/lib/scroll16.c:// 					vga_state.vga_graphics_ram[o] = (k^j)&15; // VRL samples put all colors in first 15!
src/lib/scroll16.c:// 		}
src/lib/scroll16.c:// 	}
src/lib/scroll16.c:	//word textx=0, texty=0;
src/lib/scroll16.c:	//if(i==0) i=2;
src/lib/scroll16.c:		//wwww
src/lib/scroll16.c:		modexClearRegion(page, x, y, t->tileWidth, t->tileHeight, 0); //currently the over scan color!
src/lib/scroll16.c:////0000printf("i=%d\n", i);
src/lib/scroll16.c:				//modexprint(page, x, y, 1, 15, 0, (char const *)(t->debug_data[i]));
src/lib/scroll16.c:				//draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/lib/scroll16.c:				//modexDrawBmpRegion	(page, x, y, rx, ry, t->tileWidth, t->tileHeight, (t->data));
src/lib/scroll16.c:				//modexprintbig(page, x, y, 1, 15, 0, (t->debug_data));
src/lib/scroll16.c://						modexprint(page, x+(textx*8), y+(texty*8), 1, (word)(t->debug_data), 0, (t->debug_data));
src/lib/scroll16.c://printf("y: %d\n", poopoffset);
src/lib/scroll16.c://printf("x: %d\n", poopoffset);
src/lib/scroll16.c:	//setkb(0);
src/lib/scroll16.c:	word x = (0) + gv->video.page[/*!*/(gv->video.p)].dx; // follow the screen
src/lib/scroll16.c:	word y = (0) + gv->video.page[/*!*/(gv->video.p)].dy; // follow the screen
src/lib/scroll16.c:	word col = 7, bgcol = 0, type = 1;//w = 64, h = 8,
src/lib/scroll16.c:	//byte o,o2,i;
src/lib/scroll16.c:	//modexCopyPageRegion(pip[1].page, pip[2].page, 16, 16, 16, 16, (14*8)+4, 8+4);
src/lib/scroll16.c://	vga_setup_wm1_block_copy();
src/lib/scroll16.c://	modexCopyPageRegion(&(gv->video.page[shinku_fps_indicator_page]), &(gv->video.page[!shinku_fps_indicator_page]), x, y, x+w, 0, w, h);
src/lib/scroll16.c:// 	o =	*(gv->video.page[2].data); // source offscreen
src/lib/scroll16.c:// 	o2 =	*(gv->video.page[shinku_fps_indicator_page].data)+(y * vga_state.vga_stride) + (x >> 2); // dest visible (original stride)
src/lib/scroll16.c:// 	for (i=0;i < h;i++,o += vga_state.vga_draw_stride,o2 += vga_state.vga_stride) vga_wm1_mem_block_copy(o2,o,w >> 2);
src/lib/scroll16.c://	vga_restore_rm0wm0();
src/lib/scroll16.c:        // NTS: For some bizarre reason, gv->pee is not initialized, but the pointer is not NULL even
src/lib/scroll16.c:        //      though it should be. Instead it's NULL as a near pointer but contains a non-null
src/lib/scroll16.c:        //      segment value, so testing against NULL doesn't work. It is initialized properly if
src/lib/scroll16.c:        //      you call start_timer() though which uses near malloc. Rather than fight with that,
src/lib/scroll16.c:        //      I decided it would be better to declare a temp buffer statically and sprintf to that.
src/lib/scroll16.c:        //
src/lib/scroll16.c:        //      This fixes *** Null pointer assignment detected error message in ZCROLL.EXE on exit.
src/lib/scroll16.c:		//modexClearRegion(&(gv->video.page[shinku_fps_indicator_page]), x, y, w, h, 45);
src/lib/scroll16.c://		vga_setup_wm1_block_copy();
src/lib/scroll16.c:// 		o =	*(gv->video.page[shinku_fps_indicator_page].data); // source offscreen
src/lib/scroll16.c:// 		o2 =	*(gv->video.page[2].data)+(y * vga_state.vga_stride) + (x >> 2); // dest visible (original stride)
src/lib/scroll16.c:// 		for (i=0;i < h;i++,o += vga_state.vga_draw_stride,o2 += vga_state.vga_stride) vga_wm1_mem_block_copy(o2,o,w >> 2);
src/lib/scroll16.c://		modexCopyPageRegion(&(gv->video.page[shinku_fps_indicator_page]), &(gv->video.page[!shinku_fps_indicator_page]), x, y, x, 0, w, h);
src/lib/scroll16.c://		vga_restore_rm0wm0();
src/lib/scroll16.c:	}else //copy dat sheet
src/lib/scroll16.c:			//modexprint(&(gv->video.page[shinku_fps_indicator_page]), x, y+8, type, col, bgcol, "sanic!");
src/lib/scroll16.c:			//turn this off if XT
src/lib/scroll16.c:			//modexWaitBorder();
src/lib/scroll16.c:		//vga_setup_wm1_block_copy();
src/lib/scroll16.c:		//_fmemcpy((gv->video.page[(gv->video.p)]).data, (gv->video.page[(!gv->video.p)]).data, gv->video.page[(!gv->video.p)].pagesize);
src/lib/scroll16.c:		//vga_restore_rm0wm0();
src/lib/scroll16.c:		//0000gv->video.tickclk = ((*clockw)-gv->video.startclk)/18.2;
src/lib/scroll16.c:	sword bx = x+16;	//buffer's x
src/lib/scroll16.c:	sword by = y+16;	//buffer's y
src/lib/scroll16.c:	word dire=32; //direction
src/lib/scroll16.c:	sword qq; //scroll offset
src/lib/scroll16.c:	//x-=4;
src/lib/scroll16.c:			//up
src/lib/scroll16.c:			// right
src/lib/scroll16.c:			//down
src/lib/scroll16.c:			//left
src/lib/scroll16.c:		//copy old bg to page0
src/lib/scroll16.c:		//modexCopyPageRegion(pip[3].page, pip[0].page, bx, by,	0, 0,	20, 36);
src/lib/scroll16.c:		//update buffer
src/lib/scroll16.c:		//modexCopyPageRegion(pip[0].page, pip[3].page, 0, 0,	x, y,	20, 36);
src/lib/scroll16.c://modexCopyPageRegion(page_t *dest, page_t *src, word sx, word sy, word dx, word dy, word width, word height);
src/lib/scroll16.c:	//modexCopyPageRegion(pip[3].page, pip[!(pip->video->p)].page, x-4, y-4, 0, 128, 28, 36);
src/lib/scroll16.c://	else modexCopyPageRegion(pip[1].page, pip[0].page, x-4, y-4, x-4, y-4, 28, 40);
src/lib/scroll16.c://	if(2>ls && ls>=1) { FRAME1 }else
src/lib/scroll16.c://	if(3>ls && ls>=2) { FRAME2 }else
src/lib/scroll16.c://	if(4>ls && ls>=3) { FRAME3 }else
src/lib/scroll16.c://	if(5>ls && ls>=4) { FRAME4 }
src/lib/scroll16.c:	//modexCopyPageRegion(pip[0].page, pip[3].page, 0, 0, x, y, 24, 32);
src/lib/scroll16.c:	//printf("x=%d	y=%d	bx=%d		by=%d\n", x, y, bx, by);
src/lib/scroll16.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/scroll16.h:#include "src/lib/mapread.h" //map is loaded here www
src/lib/scroll16.h://#include "src/lib/16_map.h"	//new map stuff
src/lib/scroll16.h://#define TILERENDER
src/lib/scroll16.h://modexDrawSpritePBufRegion
src/lib/scroll16.h://modexDrawBmpPBufRegion
src/lib/scroll16.h:	int tx; //appears to be the top left tile position on the viewable screen map
src/lib/scroll16.h:	int ty; //appears to be the top left tile position on the viewable screen map
src/lib/scroll16.h:	word dxThresh; //????
src/lib/scroll16.h:	word dyThresh; //????
src/lib/scroll16.h:	video_t *video;	//pointer to game variables of the video
src/lib/scroll16.h:	pan_t *pan;		//pointer the the page panning debug system
src/lib/scroll16.h://for null map!
src/lib/scroll16.h://map_t allocMap(int w, int h);
src/lib/scroll16.h://void initMap(map_t *map);
src/lib/scroll16.h://void qclean();
src/lib/typdefst.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/typdefst.h:	int dx, dy; //backwards compait
src/lib/typdefst.h:	word delta;			// How much should we shift the page for smooth scrolling
src/lib/typdefst.h:	enum direction d;			// Direction we should shift the page
src/lib/typdefst.h:	//sprite ....
src/lib/typdefst.h:	//vrs with sprite ....
src/lib/typdefst.h:	dword tiku;		//frames passed
src/lib/typdefst.h:	word clock_start;	//timer start
src/lib/typdefst.h:	word *clock;	//current time on clock
src/lib/typdefst.h:	boolean fpscap;	//cap the fps var
src/lib/typdefst.h://video
src/lib/typdefst.h:#define NUMCHUNKS	416	//keen
src/lib/typdefst.h:	char old_mode;		//old video mode before game!
src/lib/typdefst.h:	page_t page[MAXPAGE];		//pointer to root page[0]
src/lib/typdefst.h:	word vmem_remain;	//remaining video memory
src/lib/typdefst.h:	byte num_of_pages;	//number of actual pages
src/lib/typdefst.h:	boolean __near p;			//render page number
src/lib/typdefst.h:	boolean __near r;			//page flip if true
src/lib/typdefst.h:	word pr[MAXPAGE][4];	//render sections of pages
src/lib/typdefst.h:	//0000word startclk; float clk, tickclk;	//timer
src/lib/typdefst.h://from 16_mm
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h:	//word	start;	dword length;
src/lib/typdefst.h:	word	blob;	//for data larger than 64k
src/lib/typdefst.h:	memptr		*useptr;	// pointer to the segment start
src/lib/typdefst.h:	//huge struct mmblockstruct huge *next;
src/lib/typdefst.h://	boolean		PMStarted, MainPresent, EMSPresent, XMSPresent;
src/lib/typdefst.h:	//huge void huge	*farheap;
src/lib/typdefst.h:	//dword	numUMBs,UMBbase[MAXUMBS];
src/lib/typdefst.h:	//huge mmblocktype	huge mmblocks[MAXBLOCKS],huge *mmhead,huge *mmfree,huge *mmrover,huge *mmnew;
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h://from 16_pm
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h://	NOTE! PMPageSize must be an even divisor of EMSPageSize, and >= 1024
src/lib/typdefst.h:#define	PMMinMainMem	10			// Min acceptable # of pages from main
src/lib/typdefst.h:#define	PMMaxMainMem	100			// Max number of pages in main memory
src/lib/typdefst.h:#define	PMThrashThreshold	1	// Number of page thrashes before panic mode
src/lib/typdefst.h:#define	PMUnThrashThreshold	5	// Number of non-thrashing frames before leaving panic mode
src/lib/typdefst.h:			dword	offset;		// Offset of chunk into file
src/lib/typdefst.h:			word		length;		// Length of the chunk
src/lib/typdefst.h:			int			xmsPage;	// If in XMS, (xmsPage * PMPageSize) gives offset into XMS handle
src/lib/typdefst.h:			PMLockType	locked;		// If set, this page can't be purged
src/lib/typdefst.h:			int			emsPage;	// If in EMS, logical page/offset into page
src/lib/typdefst.h:			int			mainPage;	// If in Main, index into handle array
src/lib/typdefst.h:			dword	lastHit;	// Last frame number of hit
src/lib/typdefst.h:			int			baseEMSPage;	// Base EMS page for this phys frame
src/lib/typdefst.h:			dword	lastHit;		// Last frame number of hit
src/lib/typdefst.h://	Main Mem specific variables
src/lib/typdefst.h://	EMS specific variables
src/lib/typdefst.h://	XMS specific variables
src/lib/typdefst.h:	word			XMSAvail,XMSPagesAvail,XMSHandle;//,XMSVer;
src/lib/typdefst.h:	int				XMSProtectPage;// = -1;
src/lib/typdefst.h://	File specific variables
src/lib/typdefst.h:	char			PageFileName[13];// = {"VSWAP."};
src/lib/typdefst.h:	int				PageFile;// = -1;
src/lib/typdefst.h://	General usage variables
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h://from 16_ca
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h:#define NUMMAPS		4//39
src/lib/typdefst.h:  word bit0,bit1;	// 0-255 is a character, > is a pointer to a node
src/lib/typdefst.h:	int			maphandle[4];		// handle to MAPTEMP / GAMEMAPS
src/lib/typdefst.h:	ca_handle_t	file;		//files to open
src/lib/typdefst.h://==========================================================================
src/lib/typdefst.h://actual global game varables!
src/lib/typdefst.h:	video_t	video;	// video settings variable
src/lib/typdefst.h:	ca_t		ca;	// ca stuff
src/lib/typdefst.h:	pm_t		pm;	// pm stuff
src/lib/typdefst.h:	loghandle_t handle;	//handles for file logging
src/lib/typdefst.h:	kurokku_t kurokku;	//clock struct
src/lib/types.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/types.h://typedef unsigned short _seg; // it will contains segment value (as Borland _seg)
src/lib/types.h://typedef void _seg * memptr;
src/lib/types.h:typedef void _seg * memptr;//typedef void __based( void ) * memptr;	////old //----typedef void __based(__self) * memptr;
src/lib/xms.c: * Documentation on the XMS API was found on http://www.qzx.com/pc-gpe/xms30.txt
src/lib/xms.c:	//fprintf(stream, "XMS Version number: %d\n", XMSVersionNumber);
src/lib/xms.c:	//fprintf(stream, "Largest available block: %d kB (%d kB total)\n", XMSLargestBlock, XMSTotal);
src/lib/zcroll16.c: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/zcroll16.c:	// Assume everything crosses at most 1 tile at once
src/lib/zcroll16.c:	return dx && 1;//crossable_tile(x + dx, map_v) || dy && crossable_tile(y + dy, map_v);
src/lib/zcroll16.c:		// Allow movement
src/lib/zcroll16.c:		// Set speed
src/lib/zcroll16.c:		// Start animation
src/lib/zcroll16.c:		// Mark next tile as occupied
src/lib/zcroll16.c:		// Mark this tile as vacant
src/lib/zcroll16.c:		// (Un)load stuff?
src/lib/zcroll16.c://	bitmap_t bp;
src/lib/zcroll16.c:	//check for failed to load map
src/lib/zcroll16.c:		//initiate a null map!
src/lib/zcroll16.c:		map->width=MAPW;///2;
src/lib/zcroll16.c:		map->height=MAPH;///2;
src/lib/zcroll16.c://		map->data = malloc(((map->width*map->height)+1)*sizeof(byte));
src/lib/zcroll16.c:		//fix this to be far~
src/lib/zcroll16.c://		bp = bitmapLoadPcx("data/ed.pcx");
src/lib/zcroll16.c://		map->tiles->data = &bp;
src/lib/zcroll16.c://TODO: player position here
src/lib/zcroll16.c:	//if(i==0) i=2;
src/lib/zcroll16.c:		//wwww
src/lib/zcroll16.c:		modexClearRegion(page, x, y, t->tileWidth, t->tileHeight, 0); //currently the over scan color!
src/lib/zcroll16.c:////0000printf("i=%d\n", i);
src/lib/zcroll16.c:				//modexprint(page, x, y, 1, 15, 0, (char const *)(t->debug_data[i]));
src/lib/zcroll16.c:				//draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/lib/zcroll16.c:				//modexDrawBmpRegion	(page, x, y, rx, ry, t->tileWidth, t->tileHeight, (t->data));
src/lib/zcroll16.c:				//modexprintbig(page, x, y, 1, 15, 0, (t->debug_data));
src/lib/zcroll16.c://						modexprint(page, x+(textx*8), y+(texty*8), 1, (word)(t->debug_data), 0, (t->debug_data));
src/lib/zcroll16.c:	word x = (0) + gv->video.page[/*!*/(gv->video.p)].dx; // follow the screen
src/lib/zcroll16.c:	word y = (0) + gv->video.page[/*!*/(gv->video.p)].dy; // follow the screen
src/lib/zcroll16.c:		//modexClearRegion(&(gv->video.page[shinku_fps_indicator_page]), x, y, w, h, 45);
src/lib/zcroll16.c:	}else //copy dat sheet
src/lib/zcroll16.c:			//turn this off if XT
src/lib/zcroll16.c:	sword bx = x+16;	//buffer's x
src/lib/zcroll16.c:	sword by = y+16;	//buffer's y
src/lib/zcroll16.c:	word dire=32; //direction
src/lib/zcroll16.c:	sword qq; //scroll offset
src/lib/zcroll16.c:	//x-=4;
src/lib/zcroll16.c:	//y-=pip->map->tiles->tileHeight;
src/lib/zcroll16.c:			//up
src/lib/zcroll16.c:			// right
src/lib/zcroll16.c:			//down
src/lib/zcroll16.c:			//left
src/lib/zcroll16.c:		//copy old bg to page0
src/lib/zcroll16.c:		//modexCopyPageRegion(pip[3].page, pip[0].page, bx, by,	0, 0,	20, 36);
src/lib/zcroll16.c:		//update buffer
src/lib/zcroll16.c:		//modexCopyPageRegion(pip[0].page, pip[3].page, 0, 0,	x, y,	20, 36);
src/lib/zcroll16.h: * along with this program.  If not, see <http://www.gnu.org/licenses/>, or
src/lib/zcroll16.h://#include "src/lib/bakapee.h"
src/lib/zcroll16.h://#include "src/lib/16_in.h"
src/lib/zcroll16.h:#include "src/lib/16_map.h" //map is loaded here www
src/lib/zcroll16.h://#define TILERENDER
src/lib/zcroll16.h://modexDrawSpritePBufRegion
src/lib/zcroll16.h://modexDrawBmpPBufRegion
src/lib/zcroll16.h:	int tx; //appears to be the top left tile position on the viewable screen map
src/lib/zcroll16.h:	int ty; //appears to be the top left tile position on the viewable screen map
src/lib/zcroll16.h:	word dxThresh; //Threshold for physical tile switch
src/lib/zcroll16.h:	word dyThresh; //Threshold for physical tile switch
src/lib/zcroll16.h:	video_t *video;	//pointer to game variables of the video
src/lib/zcroll16.h:	pan_t *pan;		//pointer the the page panning debug system
src/lib/zcroll16.h:// Move an entity around. Should actually be in 16_entity
src/lib/zcroll16.h:// Move player around and call map scrolling if required/possible
src/lib/zcroll16.h:// Scroll map in one direction (assumed from player's movement)
src/lib/zcroll16.h://void qclean();
